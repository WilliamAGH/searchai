---
description: Convex development guidelines for this project
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx
---

# Convex Guidelines

## CRITICAL: Deployment Commands

```bash
# Development deployment (YOUR personal dev deployment)
npx convex dev                    # Continuous sync with hot reload
npx convex dev --once             # Deploy once without watching

# Production deployment (shared prod deployment)
npx convex deploy                 # Deploy to production (asks for confirmation)
npx convex deploy -y              # Deploy to production without confirmation

# Local deployment (for testing without cloud resources)
npx convex dev --local --once    # Run backend locally for E2E tests

# Useful commands
npx convex logs                  # View dev logs
npx convex logs --prod           # View production logs
npx convex run <function> --prod # Run function in production
npx convex env set KEY "value"   # Set env var in dev
npx convex env set KEY "value" --prod # Set env var in production
```

## Core Principles

- Use Convex's generated types from `./_generated/*` - never duplicate them
- All functions require `args` and `returns` validators (use `v.null()` for void)
- Use indexes instead of `.filter()` for queries
- Keep HTTP route arguments simple to avoid TypeScript depth errors

## Imports

```typescript
// Backend
import { query, mutation, action } from "./_generated/server";
import { v } from "convex/values";
import type { Doc, Id } from "./_generated/dataModel";

// Frontend  
import { api } from "../convex/_generated/api";
```

## Function Patterns

```typescript
// Public query
export const getChat = query({
  args: { chatId: v.id("chats") },
  returns: v.union(v.object({ /* ... */ }), v.null()),
  handler: async (ctx, args) => { /* ... */ }
});

// Internal mutation (prefix with internal*)
export const internalUpdateChat = internalMutation({
  args: { /* ... */ },
  returns: v.null(),
  handler: async (ctx, args) => { /* ... */ }
});
```

## UUID v7 Implementation

Use `uuidv7` package for share IDs, public IDs, and session IDs:

```typescript
// convex/lib/uuid.ts
import { uuidv7 } from "uuidv7";

export function generateShareId(): string {
  return uuidv7();
}

export function isValidUuidV7(id: string): boolean {
  const pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return pattern.test(id);
}
```

Store as `v.string()` in schema. Existing IDs remain unchanged.

## Query Best Practices

- Use `.withIndex()` not `.filter()`
- Use `.unique()` for single documents (throws if multiple match)
- No `.delete()` support - use `.collect()` then `ctx.db.delete()`
- Default order is ascending `_creationTime`

## Schema

```typescript
// Always in convex/schema.ts
export default defineSchema({
  chats: defineTable({
    title: v.string(),
    userId: v.optional(v.id("users")),
  })
  .index("by_user", ["userId"])
  .index("by_share_id", ["shareId"]), // Name includes all fields
});
```

## TypeScript

- Use `Id<"tableName">` not `string` for document IDs
- Use `Doc<"tableName">` for full documents
- Add type hints for circular references: `const result: string = await ctx.runQuery(...)`
- Use `as const` for discriminated unions

## Pagination

```typescript
import { paginationOptsValidator } from "convex/server";

export const getPaginated = query({
  args: { 
    paginationOpts: paginationOptsValidator,
    chatId: v.id("chats") 
  },
  handler: async (ctx, args) => {
    return ctx.db
      .query("messages")
      .withIndex("by_chat", q => q.eq("chatId", args.chatId))
      .order("desc")
      .paginate(args.paginationOpts);
  }
});
```

## Actions

- Add `"use node";` when using Node.js modules
- No database access (`ctx.db` unavailable)
- Call mutations/queries via `ctx.runMutation`/`ctx.runQuery`

## File Storage

```typescript
// Get URL
const url = await ctx.storage.getUrl(storageId);

// Get metadata via system table
const metadata = await ctx.db.system.get(storageId);
```

## CLI Commands

```bash
npx convex dev           # Start dev server
npx convex deploy        # Deploy to production  
npx convex logs          # View dev logs
npx convex logs --prod   # View production logs
npx convex dashboard     # Open dashboard
```

## Common Validators

- `v.id("tableName")` - Document ID
- `v.null()` - Null value (not undefined)
- `v.int64()` - BigInt (not v.bigint())
- `v.record(v.string(), v.any())` - Record type
- `v.union(...)` - Union types
- `v.literal("value")` - Literal values

## HTTP Endpoints

```typescript
// In convex/http.ts
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
  path: "/api/chat",
  method: "POST",
  handler: httpAction(async (ctx, req) => {
    const body = await req.json();
    // Validate inline, don't create type definitions
    return new Response(JSON.stringify(result));
  })
});

export default http;
```

### TS2589 Error Resolution for HTTP -> Internal Action Calls

When calling internal actions from HTTP endpoints, you may encounter:
```
error TS2589: Type instantiation is excessively deep and possibly infinite
```

This is a known TypeScript limitation with Convex's deep type system.

**FORBIDDEN SOLUTIONS:**
- ❌ Never use `@ts-ignore` or `@ts-expect-error`
- ❌ Never use `eslint-disable` comments

**ACCEPTABLE WORKAROUND (Last Resort Only):**

```typescript
/**
 * IMPORTANT TS2589 WORKAROUND:
 * Document why this pattern is necessary
 */
// Use require to avoid TS2589 at import time
const { internal } = require("../../_generated/api") as any;

// In the handler:
const result = await ctx.runAction(internal.yourNamespace.yourAction, args);
```

**Prerequisites for using this pattern:**
1. Exhausted all other solutions (helper functions, simplified types)
2. Added comprehensive JSDoc explaining why it's necessary
3. Validated all inputs at runtime
4. Used internal actions (not public) for security
5. Document the exact input/output types expected

**Better alternatives to try first:**
1. Create helper functions with simpler types
2. Break complex operations into smaller steps
3. Use type assertions on results only (not the action)
4. Consider restructuring to avoid HTTP -> internal action pattern

## References

- [Convex Docs](https://docs.convex.dev)
- [Type Generation](https://docs.convex.dev/generated-api/data-model)
- [Validators](https://docs.convex.dev/functions/validation)
