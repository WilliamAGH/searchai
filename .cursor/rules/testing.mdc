---
description: "Comprehensive testing guidelines for Node 22, Vite, React 19, Vitest, and Playwright - 2024-2025 best practices"
alwaysApply: true
---

# Testing Guidelines for SearchAI.io

This document provides comprehensive testing guidelines based on the latest 2024-2025 best practices for Vitest, Playwright, and React Testing Library, optimized for Node 22, Vite, and React 19.

## üìã Testing Stack Configuration

```yaml
# Testing Tools
UNIT_TEST_FRAMEWORK: Vitest
E2E_TEST_FRAMEWORK: Playwright
COMPONENT_TEST_LIBRARY: React Testing Library
COVERAGE_PROVIDER: V8
API_MOCKING: MSW (Mock Service Worker)

# Node & Runtime
NODE_VERSION: 22 LTS
VITE_VERSION: 6.x
REACT_VERSION: 19.1.x
TYPESCRIPT_VERSION: 5.9.x

# Test Commands
TEST_COMMAND: npm run test
TEST_UI_COMMAND: npm run test:ui
TEST_COVERAGE_COMMAND: npm run test:coverage
TEST_WATCH_COMMAND: npm run test:watch
TEST_E2E_COMMAND: npx playwright test
TEST_SMOKE_COMMAND: npm run test:smoke
```

## üö® CRITICAL TESTING RULES

### NEVER ALLOWED
- ‚ùå **NO** console.log in tests (use debugger or Vitest UI)
- ‚ùå **NO** arbitrary timeouts (use waitFor/findBy)
- ‚ùå **NO** implementation detail testing
- ‚ùå **NO** snapshot tests without review
- ‚ùå **NO** skipped tests in main/dev branches
- ‚ùå **NO** hardcoded test data that can change

### ALWAYS REQUIRED
- ‚úÖ **ALWAYS** test user-visible behavior
- ‚úÖ **ALWAYS** use semantic queries (getByRole, getByLabelText)
- ‚úÖ **ALWAYS** clean up after tests (afterEach hooks)
- ‚úÖ **ALWAYS** mock external dependencies
- ‚úÖ **ALWAYS** test error states and edge cases
- ‚úÖ **ALWAYS** maintain 80%+ coverage

## üéØ Vitest Configuration & Best Practices

### Worker Pool Selection (Vitest) and CI Strategy

Use cases and commands (from official Vitest docs):

```bash
# Force forks (child_process-based) to avoid worker termination issues
vitest run --pool=forks

# Alternative: threads (worker_threads) for performance when stable
vitest run --pool=threads

# Debug single-threaded
vitest --inspect-brk --pool threads --poolOptions.threads.singleThread
```

In CI we standardize on `vmForks` with a single worker to avoid tinypool recursion/stack issues in constrained runners:

```bash
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

Config snippets:

```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: process.env.CI ? 'vmForks' : 'forks',
    ...(process.env.CI && {
      minThreads: 1,
      maxThreads: 1,
    }),
    // Optional tuning
    // poolOptions: { forks: { singleFork: false, isolate: true } }
  }
})
```

References:
- Vitest CLI options (pool, poolOptions.*)
- Vitest Common Errors: switch to forks/vmForks to avoid worker termination issues
- Vitest Config: threads/forks/vmThreads/vmForks options

Note: This repository standardizes on Vitest, not Jest. For teams migrating from Jest, consult Vitest docs for compatibility notes; do not mix frameworks in this repo.

### Optimal Configuration for Vite Projects

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@convex': path.resolve(__dirname, './convex'),
    },
  },
  test: {
    // Environment
    environment: 'jsdom',
    globals: true,
    
    // Setup
    setupFiles: ['./src/test/setup.ts'],
    
    // Worker pool selection (verified via Vitest docs 2025)
    // - Default pool is 'forks'
    // - Use 'forks' to avoid tinypool worker termination/segfault issues
    //   See: Vitest docs -> common-errors, config, cli-generated (pool, poolOptions)
    pool: 'forks',
    
    // Coverage with V8 (faster than Istanbul)
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      include: ['src/**/*.{js,ts,jsx,tsx}'],
      exclude: [
        'src/**/*.test.{js,ts,jsx,tsx}',
        'src/**/*.spec.{js,ts,jsx,tsx}',
        'src/test/**',
        'src/**/*.d.ts',
        'src/main.tsx',
        'src/vite-env.d.ts',
        'convex/_generated/**',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    },
    
    // Test execution
    testTimeout: 10000,
    hookTimeout: 10000,
    fileParallelism: true,
    maxConcurrency: 5,
    
    // Reporters
    reporter: process.env.CI 
      ? ['default', 'json', 'html'] 
      : ['default'],
    
    // CI optimizations
    ...(process.env.CI && {
      pool: 'forks' as const,
      minWorkers: 1,
      maxWorkers: 2,
    }),
  },
})
```

### Test Setup File

```typescript
// src/test/setup.ts
import { expect, afterEach, vi } from 'vitest'
import { cleanup } from '@testing-library/react'
import * as matchers from '@testing-library/jest-dom/matchers'

// Extend Vitest matchers
expect.extend(matchers)

// Cleanup after each test
afterEach(() => {
  cleanup()
  vi.clearAllMocks()
  localStorage.clear()
  sessionStorage.clear()
})

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
  takeRecords() { return [] }
}

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}
```

## üß™ React Testing Patterns (React 19)

### Component Testing Best Practices

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ChatInterface', () => {
  // Setup user event for each test
  let user: ReturnType<typeof userEvent.setup>
  
  beforeEach(() => {
    user = userEvent.setup()
  })

  it('should handle user input correctly', async () => {
    render(<ChatInterface />)
    
    // ‚úÖ Use semantic queries
    const input = screen.getByRole('textbox', { name: /message/i })
    const sendButton = screen.getByRole('button', { name: /send/i })
    
    // ‚úÖ Simulate real user behavior
    await user.type(input, 'Hello world')
    await user.click(sendButton)
    
    // ‚úÖ Use waitFor for async operations
    await waitFor(() => {
      expect(screen.getByText('Hello world')).toBeInTheDocument()
    })
  })

  it('should handle API errors gracefully', async () => {
    // ‚úÖ Mock API failures
    const mockFetch = vi.fn().mockRejectedValueOnce(new Error('Network error'))
    global.fetch = mockFetch
    
    render(<ChatInterface />)
    
    const input = screen.getByRole('textbox', { name: /message/i })
    await user.type(input, 'Test message')
    await user.keyboard('{Enter}')
    
    // ‚úÖ Test error states
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent(/error/i)
    })
  })
})
```

### Testing Custom Hooks

```typescript
import { renderHook, act } from '@testing-library/react'
import { useChat } from '../hooks/useChat'

describe('useChat', () => {
  it('should manage chat state correctly', async () => {
    const { result } = renderHook(() => useChat())
    
    // Test initial state
    expect(result.current.messages).toEqual([])
    expect(result.current.isLoading).toBe(false)
    
    // Test actions
    await act(async () => {
      await result.current.sendMessage('Hello')
    })
    
    expect(result.current.messages).toHaveLength(1)
    expect(result.current.messages[0].content).toBe('Hello')
  })
})
```

### Testing Async Operations

```typescript
describe('Async Operations', () => {
  it('should handle data fetching', async () => {
    render(<DataComponent />)
    
    // ‚úÖ Use findBy for async elements
    const data = await screen.findByText('Data loaded', {}, { timeout: 3000 })
    expect(data).toBeInTheDocument()
    
    // ‚úÖ Alternative: Use waitFor for complex assertions
    await waitFor(() => {
      expect(screen.getByTestId('data-count')).toHaveTextContent('10')
    }, { timeout: 3000 })
  })
})
```

## üé≠ Playwright E2E Testing

### Configuration for Vite/React

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 2 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results.json' }],
  ],
  
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    
    // Vite-specific: Wait for dev server
    actionTimeout: 10000,
    navigationTimeout: 30000,
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] },
    },
  ],

  // Vite dev server integration
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
})
```

### Page Object Model Pattern

```typescript
// tests/e2e/pages/ChatPage.ts
import { Page, Locator } from '@playwright/test'

export class ChatPage {
  readonly page: Page
  readonly messageInput: Locator
  readonly sendButton: Locator
  readonly messageList: Locator
  readonly sidebar: Locator

  constructor(page: Page) {
    this.page = page
    this.messageInput = page.getByRole('textbox', { name: /type a message/i })
    this.sendButton = page.getByRole('button', { name: /send/i })
    this.messageList = page.getByRole('list', { name: /messages/i })
    this.sidebar = page.getByRole('navigation', { name: /chat history/i })
  }

  async goto() {
    await this.page.goto('/')
    await this.page.waitForLoadState('networkidle')
  }

  async sendMessage(message: string) {
    await this.messageInput.fill(message)
    await this.sendButton.click()
    
    // Wait for message to appear
    await this.page.waitForSelector(`text="${message}"`)
  }

  async expectMessageCount(count: number) {
    await expect(this.messageList.getByRole('listitem')).toHaveCount(count)
  }
}
```

### E2E Test Example

```typescript
// tests/e2e/chat.spec.ts
import { test, expect } from '@playwright/test'
import { ChatPage } from './pages/ChatPage'

test.describe('Chat Functionality', () => {
  test('user can send and receive messages', async ({ page }) => {
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    
    // Send a message
    await chatPage.sendMessage('Hello, AI!')
    
    // Verify message appears
    await expect(page.getByText('Hello, AI!')).toBeVisible()
    
    // Wait for AI response
    await page.waitForSelector('text=/thinking|typing/i', { state: 'hidden' })
    
    // Verify AI response
    await expect(page.getByText(/Hello! How can I help/i)).toBeVisible()
  })

  test('handles network errors gracefully', async ({ page, context }) => {
    // Simulate offline mode
    await context.setOffline(true)
    
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    
    await chatPage.sendMessage('Test message')
    
    // Should show error message
    await expect(page.getByRole('alert')).toContainText(/connection error/i)
  })
})
```

## üîå API Mocking with MSW

### Setup Mock Service Worker

```typescript
// src/test/mocks/handlers.ts
import { http, HttpResponse } from 'msw'

export const handlers = [
  http.post('/api/chat/send', async ({ request }) => {
    const body = await request.json()
    
    return HttpResponse.json({
      id: 'msg_123',
      content: body.content,
      role: 'user',
      timestamp: new Date().toISOString(),
    })
  }),
  
  http.get('/api/chats', () => {
    return HttpResponse.json([
      { id: 'chat_1', title: 'Test Chat 1' },
      { id: 'chat_2', title: 'Test Chat 2' },
    ])
  }),
  
  // Error simulation
  http.get('/api/error', () => {
    return HttpResponse.error()
  }),
]

// src/test/mocks/server.ts
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)
```

### Integration in Tests

```typescript
// src/test/setup.ts
import { server } from './mocks/server'

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// In specific tests
import { http, HttpResponse } from 'msw'
import { server } from '../test/mocks/server'

test('handles API errors', async () => {
  // Override handler for this test
  server.use(
    http.post('/api/chat/send', () => {
      return HttpResponse.json(
        { error: 'Service unavailable' },
        { status: 503 }
      )
    })
  )
  
  // Test error handling...
})
```

## üìä Coverage Requirements

### Minimum Coverage Thresholds

```yaml
Global Coverage:
  branches: 80%
  functions: 80%
  lines: 80%
  statements: 80%

Critical Paths (90%+ required):
  - Authentication flows
  - Payment processing
  - Data validation
  - Error handling
  - Security features

UI Components (70%+ acceptable):
  - Visual components
  - Layout components
  - Static content

Excluded from Coverage:
  - Generated code (convex/_generated)
  - Type definitions (.d.ts)
  - Test files
  - Configuration files
  - Main entry point (main.tsx)
```

## üöÄ CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Test Suite
on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x, 22.x]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Type check
        run: npm run typecheck
      
      - name: Lint
        run: npm run lint
      
      - name: Unit tests with coverage
        run: npm run test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage/coverage-final.json
          flags: unittests
          
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run E2E tests
        run: npx playwright test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
```

## üéØ Testing Checklist

### Before Every PR

- [ ] All tests pass locally (`npm run test`)
- [ ] Coverage meets thresholds (`npm run test:coverage`)
- [ ] No skipped tests (`.skip()` or `.only()`)
- [ ] E2E tests pass (`npx playwright test`)
- [ ] No console.log statements in tests
- [ ] Mocks are properly cleaned up
- [ ] Test descriptions are clear and accurate

### Test Quality Indicators

‚úÖ **Good Test**
- Tests one specific behavior
- Has clear arrange/act/assert structure
- Uses semantic queries
- Handles async operations properly
- Cleans up after itself

‚ùå **Bad Test**
- Tests implementation details
- Uses arbitrary timeouts
- Has multiple assertions for different behaviors
- Depends on test execution order
- Uses hardcoded IDs or classes

## üîç Debugging Tests

### Vitest UI Mode

```bash
# Interactive test UI
npm run test:ui

# Debug specific test
npx vitest --reporter=verbose path/to/test.spec.ts
```

### Playwright Debugging

```bash
# Debug mode with inspector
npx playwright test --debug

# UI mode for interactive debugging
npx playwright test --ui

# Generate test code
npx playwright codegen localhost:5173

# View trace after failure
npx playwright show-trace trace.zip
```

### VS Code Integration

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Vitest Tests",
      "runtimeExecutable": "npx",
      "runtimeArgs": ["vitest", "--run", "${file}"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

## üìù Test Naming Conventions

### File Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.test.tsx    # Unit tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ChatInterface.styles.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useChat.ts
‚îÇ   ‚îî‚îÄ‚îÄ useChat.test.ts               # Hook tests
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ validation.ts
‚îÇ   ‚îî‚îÄ‚îÄ validation.test.ts            # Utility tests
tests/
‚îú‚îÄ‚îÄ e2e/                              # Playwright E2E tests
‚îÇ   ‚îú‚îÄ‚îÄ chat.spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ pages/
‚îÇ       ‚îî‚îÄ‚îÄ ChatPage.ts
‚îî‚îÄ‚îÄ integration/                      # Integration tests
    ‚îî‚îÄ‚îÄ api.test.ts
```

### Test Descriptions

```typescript
// ‚úÖ Good: Descriptive and behavior-focused
describe('ChatInterface', () => {
  it('should display user message after sending', async () => {})
  it('should show error when network fails', async () => {})
  it('should disable send button while processing', async () => {})
})

// ‚ùå Bad: Vague or implementation-focused
describe('ChatInterface', () => {
  it('works', async () => {})
  it('sets state correctly', async () => {})
  it('calls API', async () => {})
})
```

## üö® Common Pitfalls to Avoid

### 1. Testing Implementation Details

```typescript
// ‚ùå BAD: Testing internal state
expect(component.state.isLoading).toBe(true)

// ‚úÖ GOOD: Testing user-visible behavior
expect(screen.getByRole('progressbar')).toBeInTheDocument()
```

### 2. Not Cleaning Up

```typescript
// ‚ùå BAD: No cleanup
test('test 1', () => {
  localStorage.setItem('key', 'value')
  // Test...
})

// ‚úÖ GOOD: Proper cleanup
afterEach(() => {
  localStorage.clear()
  vi.clearAllMocks()
})
```

### 3. Arbitrary Timeouts

```typescript
// ‚ùå BAD: Fixed timeout
await new Promise(resolve => setTimeout(resolve, 2000))

// ‚úÖ GOOD: Wait for specific condition
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument()
})
```

### 4. Testing Third-Party Libraries

```typescript
// ‚ùå BAD: Testing React Router
expect(mockNavigate).toHaveBeenCalledWith('/home')

// ‚úÖ GOOD: Testing the result
expect(window.location.pathname).toBe('/home')
```

## üéì Testing Philosophy

### The Testing Trophy (2025 Approach)

```
       /\        E2E Tests (10%)
      /  \       - Critical user journeys
     /    \      - Smoke tests
    /------\     Integration Tests (30%)
   /        \    - Component integration
  /          \   - API integration
 /            \  Unit Tests (60%)
/______________\ - Business logic
                 - Utilities
                 - Hooks
```

### Key Principles

1. **Write tests that give confidence**: Focus on critical paths
2. **Test behavior, not implementation**: What the user experiences
3. **Maintain test hygiene**: Keep tests simple, fast, and reliable
4. **Embrace the testing trophy**: More integration tests than the traditional pyramid
5. **Use the right tool**: Unit tests for logic, E2E for workflows
6. **Test accessibility**: Include a11y testing in your workflow
7. **Performance matters**: Monitor test execution time

## üîó Resources & Documentation

### Official Documentation
- [Vitest Documentation](https://vitest.dev/)
- [Playwright Documentation](https://playwright.dev/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [MSW Documentation](https://mswjs.io/)

### Recommended Reading
- [Common Testing Mistakes](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)
- [Test Patterns](https://testingjavascript.com/)
- [Effective Snapshot Testing](https://kentcdodds.com/blog/effective-snapshot-testing)

### Tools & Extensions
- VS Code: Vitest Extension
- VS Code: Playwright Test for VS Code
- Chrome: React Developer Tools
- Chrome: Testing Playground

---

**Remember**: Good tests are an investment in code quality and team velocity. They should make refactoring safe and development faster, not slower. When in doubt, test what the user would experience.
