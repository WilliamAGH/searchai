---
description: "Comprehensive testing guidelines for Node 22, Vite, React 19, Vitest, and Playwright - 2024-2025 best practices"
alwaysApply: true
---

# Testing Guidelines for SearchAI.io

This document provides comprehensive testing guidelines based on the latest 2024-2025 best practices for Vitest, Playwright, and React Testing Library, optimized for Node 22, Vite, and React 19.

## ðŸ“‹ Testing Stack Configuration

```yaml
# Testing Tools
UNIT_TEST_FRAMEWORK: Vitest
E2E_TEST_FRAMEWORK: Playwright
COMPONENT_TEST_LIBRARY: React Testing Library
COVERAGE_PROVIDER: V8
API_MOCKING: MSW (Mock Service Worker)

# Node & Runtime
NODE_VERSION: 22 LTS
VITE_VERSION: 6.x
REACT_VERSION: 19.1.x
TYPESCRIPT_VERSION: 5.9.x

# Test Commands
TEST_COMMAND: npm run test
TEST_UI_COMMAND: npm run test:ui
TEST_COVERAGE_COMMAND: npm run test:coverage
TEST_WATCH_COMMAND: npm run test:watch
TEST_E2E_COMMAND: npx playwright test
TEST_SMOKE_COMMAND: npm run test:smoke
```

## ðŸš¨ CRITICAL TESTING RULES

### NEVER ALLOWED
- âŒ **NO** console.log in tests (use debugger or Vitest UI)
- âŒ **NO** arbitrary timeouts (use waitFor/findBy)
- âŒ **NO** implementation detail testing
- âŒ **NO** snapshot tests without review
- âŒ **NO** skipped tests in main/dev branches
- âŒ **NO** hardcoded test data that can change

### ALWAYS REQUIRED
- âœ… **ALWAYS** test user-visible behavior
- âœ… **ALWAYS** use semantic queries (getByRole, getByLabelText)
- âœ… **ALWAYS** clean up after tests (afterEach hooks)
- âœ… **ALWAYS** mock external dependencies
- âœ… **ALWAYS** test error states and edge cases
- âœ… **ALWAYS** maintain 80%+ coverage

## ðŸŽ¯ Vitest Configuration & Best Practices

### Worker Pool Selection (Vitest) and CI Strategy

Use cases and commands (from official Vitest docs):

```bash
# Force forks (child_process-based) to avoid worker termination issues
vitest run --pool=forks

# Alternative: threads (worker_threads) for performance when stable
vitest run --pool=threads

# Debug single-threaded
vitest --inspect-brk --pool threads --poolOptions.threads.singleThread
```

In CI we standardize on `vmForks` with a single worker to avoid tinypool recursion/stack issues in constrained runners:

```bash
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

Config snippets:

```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: process.env.CI ? 'vmForks' : 'forks',
    ...(process.env.CI && {
      minThreads: 1,
      maxThreads: 1,
    }),
    // Optional tuning
    // poolOptions: { forks: { singleFork: false, isolate: true } }
  }
})
```

References:
- Vitest CLI options (pool, poolOptions.*)
- Vitest Common Errors: switch to forks/vmForks to avoid worker termination issues
- Vitest Config: threads/forks/vmThreads/vmForks options

Note: This repository standardizes on Vitest, not Jest. For teams migrating from Jest, consult Vitest docs for compatibility notes; do not mix frameworks in this repo.

### Optimal Configuration for Vite Projects

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@convex': path.resolve(__dirname, './convex'),
    },
  },
  test: {
    // Environment
    environment: 'jsdom',
    globals: true,
    
    // Setup
    setupFiles: ['./src/test/setup.ts'],
    
    // Worker pool selection (verified via Vitest docs 2025)
    // - Default pool is 'forks'
    // - Use 'forks' to avoid tinypool worker termination/segfault issues
    //   See: Vitest docs -> common-errors, config, cli-generated (pool, poolOptions)
    pool: 'forks',
    
    // Coverage with V8 (faster than Istanbul)
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      include: ['src/**/*.{js,ts,jsx,tsx}'],
      exclude: [
        'src/**/*.test.{js,ts,jsx,tsx}',
        'src/**/*.spec.{js,ts,jsx,tsx}',
        'src/test/**',
        'src/**/*.d.ts',
        'src/main.tsx',
        'src/vite-env.d.ts',
        'convex/_generated/**',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    },
    
    // Test execution
    testTimeout: 10000,
    hookTimeout: 10000,
    fileParallelism: true,
    maxConcurrency: 5,
    
    // Reporters
    reporter: process.env.CI 
      ? ['default', 'json', 'html'] 
      : ['default'],
    
    // CI optimizations
    ...(process.env.CI && {
      pool: 'forks' as const,
      minWorkers: 1,
      maxWorkers: 2,
    }),
  },
})
```

### Test Setup File

```typescript
// src/test/setup.ts
import { expect, afterEach, vi } from 'vitest'
import { cleanup } from '@testing-library/react'
import * as matchers from '@testing-library/jest-dom/matchers'

// Extend Vitest matchers
expect.extend(matchers)

// Cleanup after each test
afterEach(() => {
  cleanup()
  vi.clearAllMocks()
  localStorage.clear()
  sessionStorage.clear()
})

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
  takeRecords() { return [] }
}

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}
```

## ðŸ§ª React Testing Patterns (React 19)

### React 19 Specific Setup

```typescript
// React 19 Test Setup - CRITICAL for compatibility
// tests/setup.ts
import * as React from 'react'

// React 19 exports act directly - DO NOT redefine
// React Testing Library v16+ automatically handles act
const act = React.act // Use directly, don't wrap or redefine

// Set global environment flag
global.IS_REACT_ACT_ENVIRONMENT = true

// Ensure global React is available for Testing Library
if (typeof globalThis !== 'undefined' && !globalThis.React) {
  (globalThis as any).React = React
}

// Mock react-dom/test-utils for backward compatibility
vi.mock('react-dom/test-utils', () => ({
  act: React.act,
  unstable_act: React.act,
}))
```

### Component Testing Best Practices

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ChatInterface', () => {
  // Setup user event for each test
  let user: ReturnType<typeof userEvent.setup>
  
  beforeEach(() => {
    user = userEvent.setup()
  })

  it('should handle user input correctly', async () => {
    render(<ChatInterface />)
    
    // âœ… Use semantic queries
    const input = screen.getByRole('textbox', { name: /message/i })
    const sendButton = screen.getByRole('button', { name: /send/i })
    
    // âœ… Simulate real user behavior
    await user.type(input, 'Hello world')
    await user.click(sendButton)
    
    // âœ… Use waitFor for async operations
    await waitFor(() => {
      expect(screen.getByText('Hello world')).toBeInTheDocument()
    })
  })

  it('should handle API errors gracefully', async () => {
    // âœ… Mock API failures
    const mockFetch = vi.fn().mockRejectedValueOnce(new Error('Network error'))
    global.fetch = mockFetch
    
    render(<ChatInterface />)
    
    const input = screen.getByRole('textbox', { name: /message/i })
    await user.type(input, 'Test message')
    await user.keyboard('{Enter}')
    
    // âœ… Test error states
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent(/error/i)
    })
  })
})
```

### Testing Custom Hooks

```typescript
import { renderHook, act } from '@testing-library/react'
import { useChat } from '../hooks/useChat'

describe('useChat', () => {
  it('should manage chat state correctly', async () => {
    const { result } = renderHook(() => useChat())
    
    // Test initial state
    expect(result.current.messages).toEqual([])
    expect(result.current.isLoading).toBe(false)
    
    // Test actions
    await act(async () => {
      await result.current.sendMessage('Hello')
    })
    
    expect(result.current.messages).toHaveLength(1)
    expect(result.current.messages[0].content).toBe('Hello')
  })
})
```

### Testing Async Operations

```typescript
describe('Async Operations', () => {
  it('should handle data fetching', async () => {
    render(<DataComponent />)
    
    // âœ… Use findBy for async elements
    const data = await screen.findByText('Data loaded', {}, { timeout: 3000 })
    expect(data).toBeInTheDocument()
    
    // âœ… Alternative: Use waitFor for complex assertions
    await waitFor(() => {
      expect(screen.getByTestId('data-count')).toHaveTextContent('10')
    }, { timeout: 3000 })
  })
})
```

## ðŸŽ­ Playwright E2E Testing

### Common Playwright Issues & Solutions

#### WebSocket Connection Errors
```typescript
// Problem: "WebSocket connection to 'ws://localhost:5173/' failed"
// Solution 1: Ignore WebSocket errors in tests that don't need them
test('my test', async ({ page }) => {
  // Filter out WebSocket errors
  page.on('console', msg => {
    if (msg.text().includes('WebSocket connection')) return
    console.log(msg.text())
  })
  
  // Alternative: Set up console error collection with filtering
  const consoleErrors: string[] = []
  page.on('console', msg => {
    if (msg.type() === 'error' && !msg.text().includes('WebSocket')) {
      consoleErrors.push(msg.text())
    }
  })
})

// Solution 2: Ensure dev server is properly started
webServer: {
  command: 'npm run dev',
  url: 'http://localhost:5173',
  reuseExistingServer: !process.env.CI,
  timeout: 120 * 1000,
  stdout: 'pipe', // Show server output for debugging
  stderr: 'pipe',
}
```

#### Duplicate React Key Warnings
```typescript
// Problem: "Encountered two children with the same key"
// This is a CODE issue, not a test issue!
// Fix in component:
export function MessageList({ messages }) {
  return (
    <div>
      {messages.map((msg) => (
        // Ensure unique keys - use ID, not index
        <Message key={msg.id || `${msg.timestamp}-${msg.content}`} {...msg} />
      ))}
    </div>
  )
}

// In test: Assert no duplicate key warnings
test('no duplicate keys', async ({ page }) => {
  const consoleWarnings: string[] = []
  page.on('console', msg => {
    if (msg.type() === 'warning' && msg.text().includes('same key')) {
      consoleWarnings.push(msg.text())
    }
  })
  
  // ... your test
  
  expect(consoleWarnings).toHaveLength(0)
})
```

#### Mobile Sidebar Visibility Issues
```typescript
// Problem: Mobile sidebar not visible in tests
// Solution: Properly set viewport and wait for animations

test.describe('Mobile Tests', () => {
  test.use({ 
    viewport: { width: 375, height: 667 }, // iPhone size
    isMobile: true, // Enable mobile behavior
  })
  
  test('mobile sidebar opens', async ({ page }) => {
    await page.goto('/')
    
    // Click hamburger menu
    await page.getByRole('button', { name: /menu/i }).click()
    
    // Wait for animation to complete
    await page.waitForSelector('[role="dialog"]', { 
      state: 'visible',
      timeout: 5000 
    })
    
    // Alternative: Wait for specific animation class
    await page.waitForFunction(() => {
      const dialog = document.querySelector('[role="dialog"]')
      return dialog && !dialog.classList.contains('animate-out')
    })
  })
})
```

#### Share Button Not Visible
```typescript
// Problem: Share button not appearing in tests
// Solution: Ensure chat is created and messages exist first

test('share functionality', async ({ page }) => {
  // First create a chat with a message
  await page.goto('/')
  
  const input = page.getByRole('textbox', { name: /message/i })
  await input.fill('Test message')
  await input.press('Enter')
  
  // Wait for chat to be created and message to appear
  await page.waitForSelector('[data-testid="message-user"]')
  
  // Share button may only appear after chat has messages
  await expect(
    page.getByRole('button', { name: /share/i })
  ).toBeVisible({ timeout: 10000 })
})
```

### Configuration for Vite/React

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 2 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results.json' }],
  ],
  
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    
    // Vite-specific: Wait for dev server
    actionTimeout: 10000,
    navigationTimeout: 30000,
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] },
    },
  ],

  // Vite dev server integration
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
})
```

### Page Object Model Pattern

```typescript
// tests/e2e/pages/ChatPage.ts
import { Page, Locator } from '@playwright/test'

export class ChatPage {
  readonly page: Page
  readonly messageInput: Locator
  readonly sendButton: Locator
  readonly messageList: Locator
  readonly sidebar: Locator

  constructor(page: Page) {
    this.page = page
    this.messageInput = page.getByRole('textbox', { name: /type a message/i })
    this.sendButton = page.getByRole('button', { name: /send/i })
    this.messageList = page.getByRole('list', { name: /messages/i })
    this.sidebar = page.getByRole('navigation', { name: /chat history/i })
  }

  async goto() {
    await this.page.goto('/')
    await this.page.waitForLoadState('networkidle')
  }

  async sendMessage(message: string) {
    await this.messageInput.fill(message)
    await this.sendButton.click()
    
    // Wait for message to appear
    await this.page.waitForSelector(`text="${message}"`)
  }

  async expectMessageCount(count: number) {
    await expect(this.messageList.getByRole('listitem')).toHaveCount(count)
  }
}
```

### E2E Test Example

```typescript
// tests/e2e/chat.spec.ts
import { test, expect } from '@playwright/test'
import { ChatPage } from './pages/ChatPage'

test.describe('Chat Functionality', () => {
  test('user can send and receive messages', async ({ page }) => {
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    
    // Send a message
    await chatPage.sendMessage('Hello, AI!')
    
    // Verify message appears
    await expect(page.getByText('Hello, AI!')).toBeVisible()
    
    // Wait for AI response
    await page.waitForSelector('text=/thinking|typing/i', { state: 'hidden' })
    
    // Verify AI response
    await expect(page.getByText(/Hello! How can I help/i)).toBeVisible()
  })

  test('handles network errors gracefully', async ({ page, context }) => {
    // Simulate offline mode
    await context.setOffline(true)
    
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    
    await chatPage.sendMessage('Test message')
    
    // Should show error message
    await expect(page.getByRole('alert')).toContainText(/connection error/i)
  })
})
```

## ðŸ”Œ API Mocking with MSW (IMPLEMENTED âœ…)

### Setup Mock Service Worker

```typescript
// tests/mocks/search-api-mocks.ts - COMPREHENSIVE SEARCH MOCKING
import { http, HttpResponse } from 'msw'
import type { SearchResult } from '../../convex/search/providers/serpapi'

// Test scenarios for deterministic testing
export const SEARCH_TEST_SCENARIOS = {
  STANDARD: 'standard',
  NO_RESULTS: 'no_results',
  ERROR: 'error',
  TIMEOUT: 'timeout',
  RATE_LIMITED: 'rate_limited',
  PARTIAL_RESULTS: 'partial_results',
  CREATOR_QUERY: 'creator_query',
  TECHNICAL_QUERY: 'technical_query',
  CURRENT_EVENTS: 'current_events',
} as const

// Control test behavior
setSearchTestScenario(SEARCH_TEST_SCENARIOS.ERROR)
setResponseDelay(500) // Simulate network latency
setErrorRate(0.3)     // 30% random errors

// Mock handlers for all search providers
export const searchHandlers = [
  // SERP API DuckDuckGo
  http.get('https://serpapi.com/search', async ({ request }) => {
    // Returns deterministic results based on scenario
  }),
  
  // OpenRouter search & planner
  http.post('https://openrouter.ai/api/v1/chat/completions', async ({ request }) => {
    // Handles both search requests and planner requests
  }),
  
  // Direct DuckDuckGo API
  http.get('https://api.duckduckgo.com/*', async ({ request }) => {
    // Returns HTML formatted results
  }),
]

// tests/mocks/server.ts
import { setupServer } from 'msw/node'
import { searchHandlers } from './search-api-mocks'

export const server = setupServer(...searchHandlers)
```

### Integration in Tests (ACTIVE)

```typescript
// tests/mocks/setup-msw.ts - AUTO-LOADED BY VITEST
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from './server'

beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// vitest.config.ts - CONFIGURED
setupFiles: ["./tests/setup.ts", "./tests/mocks/setup-msw.ts"]
```

### Search API Testing Examples

```typescript
// Test provider fallback chain
it('should fallback through providers', async () => {
  mockSearchResponse('serp', null, 500) // Make SERP fail
  
  const results = await searchWeb({ query: 'test' })
  expect(results.searchMethod).toBe('openrouter') // Falls back
})

// Test search planner intelligence
it('should plan searches based on context', async () => {
  const plan = await planSearch({
    chatId: 'test-id',
    newMessage: 'What is React?',
    maxContextMessages: 10
  })
  
  expect(plan.shouldSearch).toBe(true)
  expect(plan.queries.length).toBeGreaterThan(0)
})

// Test error resilience
it('should handle errors gracefully', async () => {
  setSearchTestScenario(SEARCH_TEST_SCENARIOS.ERROR)
  
  const results = await searchWeb({ query: 'test' })
  expect(results.searchMethod).toBe('fallback')
  expect(results.hasRealResults).toBe(false)
})
```

### Test Helper Utilities

```typescript
import { searchTestHelper } from '../mocks/search-api-mocks'

// Track API calls
searchTestHelper.getCallCount('serp')
searchTestHelper.verifyFallbackChain()
searchTestHelper.verifyCaching('query')

// Reset between tests
searchTestHelper.reset()
```

## ðŸ” Search API Testing Best Practices (NEW)

### Available Test Scenarios

Use these predefined scenarios for comprehensive testing:

```typescript
import { SEARCH_TEST_SCENARIOS, setSearchTestScenario } from './mocks/search-api-mocks'

// Standard operation with good results
setSearchTestScenario(SEARCH_TEST_SCENARIOS.STANDARD)

// Empty results testing
setSearchTestScenario(SEARCH_TEST_SCENARIOS.NO_RESULTS)

// Network and provider errors
setSearchTestScenario(SEARCH_TEST_SCENARIOS.ERROR)
setSearchTestScenario(SEARCH_TEST_SCENARIOS.TIMEOUT)
setSearchTestScenario(SEARCH_TEST_SCENARIOS.RATE_LIMITED)

// Partial/incomplete data
setSearchTestScenario(SEARCH_TEST_SCENARIOS.PARTIAL_RESULTS)

// Domain-specific scenarios
setSearchTestScenario(SEARCH_TEST_SCENARIOS.CREATOR_QUERY)   // William Callahan detection
setSearchTestScenario(SEARCH_TEST_SCENARIOS.TECHNICAL_QUERY) // Documentation results
setSearchTestScenario(SEARCH_TEST_SCENARIOS.CURRENT_EVENTS)  // News/recent content
```

### Testing Provider Fallback Chain

```typescript
describe('Search Provider Fallback', () => {
  it('follows correct fallback order', async () => {
    // SERP API â†’ OpenRouter â†’ DuckDuckGo â†’ Fallback Links
    process.env.SERP_API_KEY = 'test'
    process.env.OPENROUTER_API_KEY = 'test'
    
    // Make first two providers fail
    mockSearchResponse('serp', null, 500)
    mockSearchResponse('openrouter', null, 503)
    
    const results = await searchWeb({ query: 'test' })
    
    // Should fall back to DuckDuckGo
    expect(results.searchMethod).toBe('duckduckgo')
    
    // Verify fallback chain was followed
    expect(searchTestHelper.verifyFallbackChain()).toBe(true)
  })
})
```

### Testing Search Planner Intelligence

```typescript
describe('Search Planner', () => {
  it('detects when search is needed', async () => {
    const informationQuery = await planSearch({
      chatId: 'test',
      newMessage: 'What is the latest AI news?',
      maxContextMessages: 10
    })
    expect(informationQuery.shouldSearch).toBe(true)
    
    const greeting = await planSearch({
      chatId: 'test',
      newMessage: 'Hello there!',
      maxContextMessages: 10
    })
    expect(greeting.shouldSearch).toBe(false)
  })
  
  it('suggests new chat for topic changes', async () => {
    const plan = await planSearch({
      chatId: 'test',
      newMessage: 'Let\'s talk about something completely different',
      maxContextMessages: 10
    })
    expect(plan.suggestNewChat).toBe(true)
  })
})
```

### Testing Error Resilience

```typescript
describe('Error Handling', () => {
  it('handles intermittent failures', async () => {
    setErrorRate(0.3) // 30% failure rate
    
    const attempts = 10
    const results = await Promise.allSettled(
      Array(attempts).fill(null).map(() => 
        searchWeb({ query: 'test', maxResults: 5 })
      )
    )
    
    const successful = results.filter(r => r.status === 'fulfilled')
    expect(successful.length).toBeGreaterThan(attempts * 0.5)
  })
  
  it('handles slow networks', async () => {
    setResponseDelay(2000) // 2 second delay
    
    const start = Date.now()
    await searchWeb({ query: 'test' })
    const duration = Date.now() - start
    
    expect(duration).toBeGreaterThanOrEqual(2000)
  })
})
```

### Testing Cache Behavior

```typescript
describe('Search Caching', () => {
  it('caches identical queries', async () => {
    const query = 'test caching'
    
    // First call - hits API
    const result1 = await searchWeb({ query, maxResults: 5 })
    const callCount1 = searchTestHelper.getCallCount()
    
    // Second call - should use cache
    const result2 = await searchWeb({ query, maxResults: 5 })
    const callCount2 = searchTestHelper.getCallCount()
    
    expect(result1).toEqual(result2)
    expect(callCount2).toBe(callCount1) // No new API calls
    expect(searchTestHelper.verifyCaching(query)).toBe(true)
  })
})
```

### E2E Search Testing with Playwright

```typescript
// tests/e2e/search-with-mocks.spec.ts
import { test, expect } from '@playwright/test'
import { setSearchTestScenario, SEARCH_TEST_SCENARIOS } from '../mocks/search-api-mocks'

test('handles search results in UI', async ({ page }) => {
  setSearchTestScenario(SEARCH_TEST_SCENARIOS.TECHNICAL_QUERY)
  
  await page.goto('/')
  const input = page.locator('[role="textbox"]').first()
  
  await input.type('How do React hooks work?')
  await page.keyboard.press('Enter')
  
  // Wait for response with search results
  await expect(input).toBeEnabled({ timeout: 30000 })
  
  // Verify search results are integrated
  const response = page.locator('[data-testid="message-assistant"]').last()
  await expect(response).toContainText(/React/)
})
```

### Debugging Search Tests

```typescript
// Enable detailed logging
import { searchTestHelper } from './mocks/search-api-mocks'

// After test execution
console.log('API Calls:', searchTestHelper.getCallCount())
console.log('Last Call:', searchTestHelper.getLastCall())
console.log('Fallback Chain Valid:', searchTestHelper.verifyFallbackChain())

// Check specific provider calls
console.log('SERP calls:', searchTestHelper.getCallCount('serp'))
console.log('OpenRouter calls:', searchTestHelper.getCallCount('openrouter'))
console.log('DuckDuckGo calls:', searchTestHelper.getCallCount('duckduckgo'))
```

## ðŸ“Š Coverage Requirements

### Minimum Coverage Thresholds

```yaml
Global Coverage:
  branches: 80%
  functions: 80%
  lines: 80%
  statements: 80%

Critical Paths (90%+ required):
  - Authentication flows
  - Payment processing
  - Data validation
  - Error handling
  - Security features

UI Components (70%+ acceptable):
  - Visual components
  - Layout components
  - Static content

Excluded from Coverage:
  - Generated code (convex/_generated)
  - Type definitions (.d.ts)
  - Test files
  - Configuration files
  - Main entry point (main.tsx)
```

## ðŸš€ CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Test Suite
on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x, 22.x]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Type check
        run: npm run typecheck
      
      - name: Lint
        run: npm run lint
      
      - name: Unit tests with coverage
        run: npm run test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage/coverage-final.json
          flags: unittests
          
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run E2E tests
        run: npx playwright test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
```

## ðŸŽ¯ Testing Checklist

### Before Every PR

- [ ] All tests pass locally (`npm run test`)
- [ ] Coverage meets thresholds (`npm run test:coverage`)
- [ ] No skipped tests (`.skip()` or `.only()`)
- [ ] E2E tests pass (`npx playwright test`)
- [ ] No console.log statements in tests
- [ ] Mocks are properly cleaned up
- [ ] Test descriptions are clear and accurate

### Test Quality Indicators

âœ… **Good Test**
- Tests one specific behavior
- Has clear arrange/act/assert structure
- Uses semantic queries
- Handles async operations properly
- Cleans up after itself

âŒ **Bad Test**
- Tests implementation details
- Uses arbitrary timeouts
- Has multiple assertions for different behaviors
- Depends on test execution order
- Uses hardcoded IDs or classes

## ðŸ” Debugging Tests

### Vitest UI Mode

```bash
# Interactive test UI
npm run test:ui

# Debug specific test
npx vitest --reporter=verbose path/to/test.spec.ts
```

### Playwright Debugging

```bash
# Debug mode with inspector
npx playwright test --debug

# UI mode for interactive debugging
npx playwright test --ui

# Generate test code
npx playwright codegen localhost:5173

# View trace after failure
npx playwright show-trace trace.zip
```

### VS Code Integration

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Vitest Tests",
      "runtimeExecutable": "npx",
      "runtimeArgs": ["vitest", "--run", "${file}"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

## ðŸ“ Test Naming Conventions

### File Structure

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ChatInterface/
â”‚   â”‚   â”œâ”€â”€ ChatInterface.tsx
â”‚   â”‚   â”œâ”€â”€ ChatInterface.test.tsx    # Unit tests
â”‚   â”‚   â””â”€â”€ ChatInterface.styles.ts
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useChat.ts
â”‚   â””â”€â”€ useChat.test.ts               # Hook tests
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ validation.ts
â”‚   â””â”€â”€ validation.test.ts            # Utility tests
tests/
â”œâ”€â”€ e2e/                              # Playwright E2E tests
â”‚   â”œâ”€â”€ chat.spec.ts
â”‚   â””â”€â”€ pages/
â”‚       â””â”€â”€ ChatPage.ts
â””â”€â”€ integration/                      # Integration tests
    â””â”€â”€ api.test.ts
```

### Test Descriptions

```typescript
// âœ… Good: Descriptive and behavior-focused
describe('ChatInterface', () => {
  it('should display user message after sending', async () => {})
  it('should show error when network fails', async () => {})
  it('should disable send button while processing', async () => {})
})

// âŒ Bad: Vague or implementation-focused
describe('ChatInterface', () => {
  it('works', async () => {})
  it('sets state correctly', async () => {})
  it('calls API', async () => {})
})
```

## ðŸš¨ Common Pitfalls to Avoid

### React 19 Specific Pitfalls

#### 1. Trying to Redefine React.act
```typescript
// âŒ BAD: Will throw "Cannot redefine property: act"
if (!React.act) {
  (React as any).act = customAct
}

// âœ… GOOD: Use React.act directly
const act = React.act // React 19 exports it
```

#### 2. Using Outdated Testing Library Versions
```json
// âŒ BAD: Old versions don't support React 19
"@testing-library/react": "^14.0.0"

// âœ… GOOD: Use v16+ for React 19
"@testing-library/react": "^16.0.0"
```

### 1. Testing Implementation Details

```typescript
// âŒ BAD: Testing internal state
expect(component.state.isLoading).toBe(true)

// âœ… GOOD: Testing user-visible behavior
expect(screen.getByRole('progressbar')).toBeInTheDocument()
```

### 2. Not Cleaning Up

```typescript
// âŒ BAD: No cleanup
test('test 1', () => {
  localStorage.setItem('key', 'value')
  // Test...
})

// âœ… GOOD: Proper cleanup
afterEach(() => {
  localStorage.clear()
  vi.clearAllMocks()
})
```

### 3. Arbitrary Timeouts

```typescript
// âŒ BAD: Fixed timeout
await new Promise(resolve => setTimeout(resolve, 2000))

// âœ… GOOD: Wait for specific condition
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument()
})
```

### 4. Testing Third-Party Libraries

```typescript
// âŒ BAD: Testing React Router
expect(mockNavigate).toHaveBeenCalledWith('/home')

// âœ… GOOD: Testing the result
expect(window.location.pathname).toBe('/home')
```

## ðŸŽ“ Testing Philosophy

### The Testing Trophy (2025 Approach)

```
       /\        E2E Tests (10%)
      /  \       - Critical user journeys
     /    \      - Smoke tests
    /------\     Integration Tests (30%)
   /        \    - Component integration
  /          \   - API integration
 /            \  Unit Tests (60%)
/______________\ - Business logic
                 - Utilities
                 - Hooks
```

### Key Principles

1. **Write tests that give confidence**: Focus on critical paths
2. **Test behavior, not implementation**: What the user experiences
3. **Maintain test hygiene**: Keep tests simple, fast, and reliable
4. **Embrace the testing trophy**: More integration tests than the traditional pyramid
5. **Use the right tool**: Unit tests for logic, E2E for workflows
6. **Test accessibility**: Include a11y testing in your workflow
7. **Performance matters**: Monitor test execution time

## ðŸ”— Resources & Documentation

### Official Documentation
- [Vitest Documentation](https://vitest.dev/)
- [Playwright Documentation](https://playwright.dev/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [MSW Documentation](https://mswjs.io/)

### Recommended Reading
- [Common Testing Mistakes](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)
- [Test Patterns](https://testingjavascript.com/)
- [Effective Snapshot Testing](https://kentcdodds.com/blog/effective-snapshot-testing)

### Tools & Extensions
- VS Code: Vitest Extension
- VS Code: Playwright Test for VS Code
- Chrome: React Developer Tools
- Chrome: Testing Playground

## ðŸ”§ Troubleshooting Guide

### Vitest Issues

#### Worker Pool Errors
```bash
# Error: "Cannot find module" or worker termination
# Solution: Switch to forks pool
vitest run --pool=forks

# For CI environments
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

#### Memory Issues in CI
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    pool: 'forks',
    poolOptions: {
      forks: {
        singleFork: true, // Run tests sequentially in one process
      }
    },
    maxConcurrency: 1, // Limit concurrent tests
  }
})
```

### Playwright Issues

#### Tests Failing Only in CI
```typescript
// playwright.config.ts
export default defineConfig({
  // Increase timeouts for CI
  use: {
    actionTimeout: process.env.CI ? 30000 : 10000,
    navigationTimeout: process.env.CI ? 60000 : 30000,
  },
  
  // More retries in CI
  retries: process.env.CI ? 3 : 1,
  
  // Disable parallelism if flaky
  workers: process.env.CI ? 1 : undefined,
})
```

#### Network Errors (ERR_CONNECTION_REFUSED)
```typescript
// Ensure server is ready before tests
webServer: {
  command: 'npm run dev',
  url: 'http://localhost:5173',
  reuseExistingServer: !process.env.CI,
  // Add health check
  timeout: 120 * 1000,
  stdout: 'pipe',
  stderr: 'pipe',
}

// Or use custom wait logic
test.beforeAll(async () => {
  // Wait for server to be ready
  await waitForServer('http://localhost:5173', { timeout: 30000 })
})
```

### React Testing Library Issues

#### Act Warnings
```typescript
// Warning: "An update was not wrapped in act(...)"
// Solution 1: Use async utilities
await waitFor(() => {
  expect(screen.getByText('Done')).toBeInTheDocument()
})

// Solution 2: Ensure all updates complete
await act(async () => {
  await userEvent.click(button)
})

// Solution 3: For React 19, act is automatic with RTL v16+
// Just ensure you're using the latest version
```

#### Timeout Issues
```typescript
// Increase timeout for slow operations
await waitFor(
  () => expect(screen.getByText('Loaded')).toBeInTheDocument(),
  { timeout: 5000 } // Default is 1000ms
)

// For findBy queries
const element = await screen.findByText('Loaded', {}, { timeout: 5000 })
```

---

**Remember**: Good tests are an investment in code quality and team velocity. They should make refactoring safe and development faster, not slower. When in doubt, test what the user would experience.
