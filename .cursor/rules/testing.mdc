---
description: "Testing: Vitest, Playwright, React 19, Convex - 2025"
alwaysApply: true
---

# Testing Guidelines

## Contents
- Stack & Commands
- Vitest Configuration & Best Practices
- React Testing Patterns (React 19)
- Playwright E2E Testing
- API Mocking with MSW
- Search API Testing Best Practices
- Coverage Requirements
- CI/CD Integration
- Testing Checklist
- Debugging Tests
- Test Naming Conventions
- Common Pitfalls to Avoid
- Testing Philosophy
- Convex Database Type Testing
- Resources & Documentation
- Troubleshooting Guide

Tip: Use your editor's outline/section navigation to jump to any section. All examples and guidance are preserved; wording is kept concise.

## üöÄ Stack & Commands

```yaml
STACK: Vitest + Playwright + RTL v16 + MSW + Convex Test
RUNTIME: Node 22, Vite 6, React 19.1, TS 5.9
COVERAGE: V8 80%+ | POOL: forks (local), vmForks (CI)
```

```bash
npm run test[|:ui|:coverage|:watch]  # Unit tests
npx playwright test                   # E2E
npm run validate:convex               # Types
```

**NEVER:** console.log ‚Üí debugger | timeouts ‚Üí waitFor | implementation ‚Üí behavior | hardcoded data ‚Üí factories | skip in main  
**ALWAYS:** semantic queries | afterEach cleanup | mock externals | test errors | 80%+ coverage

## üéØ Vitest Configuration & Best Practices

### Worker Pool Selection (Vitest) and CI Strategy

Use cases and commands (from official Vitest docs):

```bash
# Force forks (child_process-based) to avoid worker termination issues
vitest run --pool=forks

# Alternative: threads (worker_threads) for performance when stable
vitest run --pool=threads

# Debug single-threaded
vitest --inspect-brk --pool=threads --poolOptions.threads.singleThread
```

In CI we standardize on `vmForks` with a single worker to avoid tinypool recursion/stack issues in constrained runners:

```bash
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

Config snippets:

```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: process.env.CI ? 'vmForks' : 'forks',
    ...(process.env.CI && {
      minThreads: 1,
      maxThreads: 1,
    }),
    // Optional tuning
    // poolOptions: { forks: { singleFork: false, isolate: true } }
  }
})
```

References:
- Vitest CLI: <https://vitest.dev/guide/cli.html>
- Vitest Common Errors: <https://vitest.dev/guide/common-errors.html>
- Vitest Config: <https://vitest.dev/config/>

Note: This repository standardizes on Vitest, not Jest. For teams migrating from Jest, consult Vitest docs for compatibility notes; do not mix frameworks in this repo.

### Optimal Configuration for Vite Projects

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@convex': path.resolve(__dirname, './convex'),
    },
  },
  test: {
    // Environment
    environment: 'jsdom',
    globals: true,
    
    // Setup
    setupFiles: ['./tests/setup.ts'],
    
    // Worker pool selection
    // Local: forks | CI: vmForks (singleFork) to avoid worker termination in constrained runners
    pool: process.env.CI ? 'vmForks' : 'forks',
    
    // Coverage with V8 (faster than Istanbul)
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      include: ['src/**/*.{js,ts,jsx,tsx}'],
      exclude: [
        'src/**/*.test.{js,ts,jsx,tsx}',
        'src/**/*.spec.{js,ts,jsx,tsx}',
        'src/test/**',
        'src/**/*.d.ts',
        'src/main.tsx',
        'src/vite-env.d.ts',
        'convex/_generated/**',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    },
    
    // Test execution
    testTimeout: 10000,
    hookTimeout: 10000,
    fileParallelism: true,
    maxConcurrency: 5,
    
    // Reporters
    reporter: process.env.CI 
      ? ['default', 'json', 'html'] 
      : ['default'],
    
    // CI optimizations
    ...(process.env.CI && {
      poolOptions: { vmForks: { singleFork: true } },
      maxConcurrency: 1,
    }),
  },
})
```

### Test Setup File

```typescript
// src/test/setup.ts (use tests/setup.ts in this repo)
import { expect, afterEach, vi } from 'vitest'
import { cleanup } from '@testing-library/react'
import * as matchers from '@testing-library/jest-dom/matchers'

// Extend Vitest matchers
expect.extend(matchers)

// Cleanup after each test
afterEach(() => {
  cleanup()
  vi.clearAllMocks()
  localStorage.clear()
  sessionStorage.clear()
})

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock IntersectionObserver
const MockIntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
  takeRecords() { return [] }
}
;(globalThis as any).IntersectionObserver = MockIntersectionObserver
;(window as any).IntersectionObserver = MockIntersectionObserver

// Mock ResizeObserver
const MockResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}
;(globalThis as any).ResizeObserver = MockResizeObserver
;(window as any).ResizeObserver = MockResizeObserver
```

## üß™ React Testing Patterns (React 19)

### React 19 Specific Setup

```typescript
// React 19 Test Setup - CRITICAL for compatibility
// tests/setup.ts
import * as React from 'react'
import { vi } from 'vitest'

// React 19 exports act directly - DO NOT redefine
// React Testing Library v16+ automatically handles act
const act = React.act // Use directly, don't wrap or redefine

// Set global environment flag
global.IS_REACT_ACT_ENVIRONMENT = true

// Ensure global React is available for Testing Library
if (typeof globalThis !== 'undefined' && !globalThis.React) {
  (globalThis as any).React = React
}

// Mock react-dom/test-utils for backward compatibility
vi.mock('react-dom/test-utils', () => ({
  act: React.act,
  unstable_act: React.act,
}))
```

### Component Testing Best Practices

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ChatInterface', () => {
  // Setup user event for each test
  let user: ReturnType<typeof userEvent.setup>
  
  beforeEach(() => {
    user = userEvent.setup()
  })

  it('should handle user input correctly', async () => {
    render(<ChatInterface />)
    
    // ‚úÖ Use semantic queries
    const input = screen.getByRole('textbox', { name: /message/i })
    const sendButton = screen.getByRole('button', { name: /send/i })
    
    // ‚úÖ Simulate real user behavior
    await user.type(input, 'Hello world')
    await user.click(sendButton)
    
    // ‚úÖ Use waitFor for async operations
    await waitFor(() => {
      expect(screen.getByText('Hello world')).toBeInTheDocument()
    })
  })

  it('should handle API errors gracefully', async () => {
    // ‚úÖ Mock API failures
    const mockFetch = vi.fn().mockRejectedValueOnce(new Error('Network error'))
    global.fetch = mockFetch
    
    render(<ChatInterface />)
    
    const input = screen.getByRole('textbox', { name: /message/i })
    await user.type(input, 'Test message')
    await user.keyboard('{Enter}')
    
    // ‚úÖ Test error states
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent(/error/i)
    })
  })
})
```

### Testing Custom Hooks

```typescript
import { renderHook } from '@testing-library/react'
import { useChat } from '../hooks/useChat'

describe('useChat', () => {
  it('should manage chat state correctly', async () => {
    const { result } = renderHook(() => useChat())
    
    // Test initial state
    expect(result.current.messages).toEqual([])
    expect(result.current.isLoading).toBe(false)
    
    // Test actions
    await result.current.sendMessage('Hello')
    
    expect(result.current.messages).toHaveLength(1)
    expect(result.current.messages[0].content).toBe('Hello')
  })
})
```

### Testing Async Operations

```typescript
describe('Async Operations', () => {
  it('should handle data fetching', async () => {
    render(<DataComponent />)
    
    // ‚úÖ Use findBy for async elements
    const data = await screen.findByText('Data loaded', {}, { timeout: 3000 })
    expect(data).toBeInTheDocument()
    
    // ‚úÖ Alternative: Use waitFor for complex assertions
    await waitFor(() => {
      expect(screen.getByTestId('data-count')).toHaveTextContent('10')
    }, { timeout: 3000 })
  })
})
```

## üé≠ Playwright E2E Testing

### Common Playwright Issues & Solutions

#### WebSocket Connection Errors
```typescript
// Problem: "WebSocket connection to 'ws://localhost:5173/' failed"
// Solution 1: Ignore WebSocket errors in tests that don't need them
test('my test', async ({ page }) => {
  // Filter out WebSocket errors
  page.on('console', msg => {
    if (msg.text().includes('WebSocket connection')) return
    console.log(msg.text())
  })
  
  // Alternative: Set up console error collection with filtering
  const consoleErrors: string[] = []
  page.on('console', msg => {
    if (msg.type() === 'error' && !msg.text().includes('WebSocket')) {
      consoleErrors.push(msg.text())
    }
  })
})

// Solution 2: Ensure dev server is properly started
webServer: {
  command: 'npm run dev',
  url: 'http://localhost:5173',
  reuseExistingServer: !process.env.CI,
  timeout: 120 * 1000,
  stdout: 'pipe', // Show server output for debugging
  stderr: 'pipe',
}
```

#### Duplicate React Key Warnings
```typescript
// Problem: "Encountered two children with the same key"
// This is a CODE issue, not a test issue!
// Fix in component:
export function MessageList({ messages }) {
  return (
    <div>
      {messages.map((msg) => (
        // Ensure unique keys - use ID, not index
        <Message key={msg.id || `${msg.timestamp}-${msg.content}`} {...msg} />
      ))}
    </div>
  )
}

// In test: Assert no duplicate key warnings
test('no duplicate keys', async ({ page }) => {
  const consoleWarnings: string[] = []
  page.on('console', msg => {
    if (msg.type() === 'warning' && msg.text().includes('same key')) {
      consoleWarnings.push(msg.text())
    }
  })
  
  // ... your test
  
  expect(consoleWarnings).toHaveLength(0)
})
```

#### Mobile Sidebar Visibility Issues
```typescript
// Problem: Mobile sidebar not visible in tests
// Solution: Properly set viewport and wait for animations

test.describe('Mobile Tests', () => {
  test.use({ 
    viewport: { width: 375, height: 667 }, // iPhone size
    isMobile: true, // Enable mobile behavior
  })
  
  test('mobile sidebar opens', async ({ page }) => {
    await page.goto('/')
    
    // Click hamburger menu
    await page.getByRole('button', { name: /menu/i }).click()
    
    // Wait for animation to complete
    await page.waitForSelector('[role="dialog"]', { 
      state: 'visible',
      timeout: 5000 
    })
    
    // Alternative: Wait for specific animation class
    await page.waitForFunction(() => {
      const dialog = document.querySelector('[role="dialog"]')
      return dialog && !dialog.classList.contains('animate-out')
    })
  })
})
```

#### Share Button Not Visible
```typescript
// Problem: Share button not appearing in tests
// Solution: Ensure chat is created and messages exist first

test('share functionality', async ({ page }) => {
  // First create a chat with a message
  await page.goto('/')
  
  const input = page.getByRole('textbox', { name: /message/i })
  await input.fill('Test message')
  await input.press('Enter')
  
  // Wait for chat to be created and message to appear
  await page.waitForSelector('[data-testid="message-user"]')
  
  // Share button may only appear after chat has messages
  await expect(
    page.getByRole('button', { name: /share/i })
  ).toBeVisible({ timeout: 10000 })
})
```

### Configuration for Vite/React

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results.json' }],
  ],
  
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    
    // Vite-specific: Wait for dev server
    actionTimeout: 10000,
    navigationTimeout: 30000,
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] },
    },
  ],

  // Vite dev server integration
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
})
```

### Page Object Model Pattern

```typescript
// tests/e2e/pages/ChatPage.ts
import { Page, Locator, expect } from '@playwright/test'

export class ChatPage {
  readonly page: Page
  readonly messageInput: Locator
  readonly sendButton: Locator
  readonly messageList: Locator
  readonly sidebar: Locator

  constructor(page: Page) {
    this.page = page
    this.messageInput = page.getByRole('textbox', { name: /type a message/i })
    this.sendButton = page.getByRole('button', { name: /send/i })
    this.messageList = page.getByRole('list', { name: /messages/i })
    this.sidebar = page.getByRole('navigation', { name: /chat history/i })
  }

  async goto() {
    await this.page.goto('/')
    await this.page.waitForLoadState('networkidle')
  }

  async sendMessage(message: string) {
    await this.messageInput.fill(message)
    await this.sendButton.click()
    
    // Wait for message to appear
    await this.page.waitForSelector(`text="${message}"`)
  }

  async expectMessageCount(count: number) {
    await expect(this.messageList.getByRole('listitem')).toHaveCount(count)
  }
}
```

### E2E Test Example

```typescript
// tests/e2e/chat.spec.ts
import { test, expect } from '@playwright/test'
import { ChatPage } from './pages/ChatPage'

test.describe('Chat Functionality', () => {
  test('user can send and receive messages', async ({ page }) => {
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    
    // Send a message
    await chatPage.sendMessage('Hello, AI!')
    
    // Verify message appears
    await expect(page.getByText('Hello, AI!')).toBeVisible()
    
    // Wait for AI response
    await page.waitForSelector('text=/thinking|typing/i', { state: 'hidden' })
    
    // Verify AI response
    await expect(page.getByText(/Hello! How can I help/i)).toBeVisible()
  })

  test('handles network errors gracefully', async ({ page, context }) => {
    const chatPage = new ChatPage(page)
    await chatPage.goto()
    await context.setOffline(true)
    
    await chatPage.sendMessage('Test message')
    
    // Should show error message
    await expect(page.getByRole('alert')).toContainText(/connection error/i)
    await context.setOffline(false) // cleanup
  })
})
```

## üîå API Mocking with MSW (IMPLEMENTED ‚úÖ)

### Setup Mock Service Worker

```typescript
// tests/mocks/search-api-mocks.ts - COMPREHENSIVE SEARCH MOCKING
import { http, HttpResponse } from 'msw'
import type { SearchResult } from '../../convex/search/providers/serpapi'

// Test scenarios for deterministic testing
export const SEARCH_TEST_SCENARIOS = {
  STANDARD: 'standard',
  NO_RESULTS: 'no_results',
  ERROR: 'error',
  TIMEOUT: 'timeout',
  RATE_LIMITED: 'rate_limited',
  PARTIAL_RESULTS: 'partial_results',
  CREATOR_QUERY: 'creator_query',
  TECHNICAL_QUERY: 'technical_query',
  CURRENT_EVENTS: 'current_events',
} as const

// Control test behavior (set per-test in beforeEach, not at module top)
// Example usage in tests:
// beforeEach(() => {
//   setSearchTestScenario(SEARCH_TEST_SCENARIOS.STANDARD)
//   setResponseDelay(0)
//   setErrorRate(0)
// })

// Mock handlers for all search providers
export const searchHandlers = [
  // SERP API DuckDuckGo
  http.get('https://serpapi.com/search', async ({ request }) => {
    // Returns deterministic results based on scenario
  }),
  
  // OpenRouter search & planner
  http.post('https://openrouter.ai/api/v1/chat/completions', async ({ request }) => {
    // Handles both search requests and planner requests
  }),
  
  // Direct DuckDuckGo API
  http.get('https://api.duckduckgo.com/*', async ({ request }) => {
    // Returns HTML formatted results
  }),
]

// tests/mocks/server.ts
import { setupServer } from 'msw/node'
import { searchHandlers } from './search-api-mocks'

export const server = setupServer(...searchHandlers)
```

### Integration in Tests (ACTIVE)

```typescript
// tests/mocks/setup-msw.ts - AUTO-LOADED BY VITEST
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from './server'

beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// vitest.config.ts - CONFIGURED
setupFiles: ["./tests/setup.ts", "./tests/mocks/setup-msw.ts"]
```

### Search API Testing Examples

```typescript
// Test provider fallback chain
// import { mockSearchResponse, searchTestHelper } from '../mocks/search-api-mocks'
it('should fallback through providers', async () => {
  mockSearchResponse('serp', null, 500) // Make SERP fail
  
  const results = await searchWeb({ query: 'test' })
  expect(results.searchMethod).toBe('openrouter') // Falls back
})

// Test search planner intelligence
it('should plan searches based on context', async () => {
  const plan = await planSearch({
    chatId: 'test-id',
    newMessage: 'What is React?',
    maxContextMessages: 10
  })
  
  expect(plan.shouldSearch).toBe(true)
  expect(plan.queries.length).toBeGreaterThan(0)
})

// Test error resilience
it('should handle errors gracefully', async () => {
  setSearchTestScenario(SEARCH_TEST_SCENARIOS.ERROR)
  
  const results = await searchWeb({ query: 'test' })
  expect(results.searchMethod).toBe('fallback')
  expect(results.hasRealResults).toBe(false)
})
```

### Test Helper Utilities

```typescript
import { searchTestHelper } from '../mocks/search-api-mocks'

// Track API calls
searchTestHelper.getCallCount('serp')
searchTestHelper.verifyFallbackChain()
searchTestHelper.verifyCaching('query')

// Reset between tests
searchTestHelper.reset()
```

## üîç Search API Testing Best Practices (NEW)

### Available Test Scenarios

Use these predefined scenarios for comprehensive testing:

```typescript
import { SEARCH_TEST_SCENARIOS, setSearchTestScenario } from './mocks/search-api-mocks'

// Standard operation with good results
setSearchTestScenario(SEARCH_TEST_SCENARIOS.STANDARD)

// Empty results testing
setSearchTestScenario(SEARCH_TEST_SCENARIOS.NO_RESULTS)

// Network and provider errors
setSearchTestScenario(SEARCH_TEST_SCENARIOS.ERROR)
setSearchTestScenario(SEARCH_TEST_SCENARIOS.TIMEOUT)
setSearchTestScenario(SEARCH_TEST_SCENARIOS.RATE_LIMITED)

// Partial/incomplete data
setSearchTestScenario(SEARCH_TEST_SCENARIOS.PARTIAL_RESULTS)

// Domain-specific scenarios
setSearchTestScenario(SEARCH_TEST_SCENARIOS.CREATOR_QUERY)   // William Callahan detection
setSearchTestScenario(SEARCH_TEST_SCENARIOS.TECHNICAL_QUERY) // Documentation results
setSearchTestScenario(SEARCH_TEST_SCENARIOS.CURRENT_EVENTS)  // News/recent content
```

### Testing Provider Fallback Chain

```typescript
describe('Search Provider Fallback', () => {
  it('follows correct fallback order', async () => {
    // SERP API ‚Üí OpenRouter ‚Üí DuckDuckGo ‚Üí Fallback Links
    process.env.SERP_API_KEY = 'test'
    process.env.OPENROUTER_API_KEY = 'test'
    
    // Make first two providers fail
    mockSearchResponse('serp', null, 500)
    mockSearchResponse('openrouter', null, 503)
    
    const results = await searchWeb({ query: 'test' })
    
    // Should fall back to DuckDuckGo
    expect(results.searchMethod).toBe('duckduckgo')
    
    // Verify fallback chain was followed
    expect(searchTestHelper.verifyFallbackChain()).toBe(true)
  })
})
```

### Testing Search Planner Intelligence

```typescript
describe('Search Planner', () => {
  it('detects when search is needed', async () => {
    const informationQuery = await planSearch({
      chatId: 'test',
      newMessage: 'What is the latest AI news?',
      maxContextMessages: 10
    })
    expect(informationQuery.shouldSearch).toBe(true)
    
    const greeting = await planSearch({
      chatId: 'test',
      newMessage: 'Hello there!',
      maxContextMessages: 10
    })
    expect(greeting.shouldSearch).toBe(false)
  })
  
  it('suggests new chat for topic changes', async () => {
    const plan = await planSearch({
      chatId: 'test',
      newMessage: 'Let\'s talk about something completely different',
      maxContextMessages: 10
    })
    expect(plan.suggestNewChat).toBe(true)
  })
})
```

### Testing Error Resilience

```typescript
describe('Error Handling', () => {
  it('handles intermittent failures', async () => {
    setErrorRate(0.3) // 30% failure rate
    
    const attempts = 10
    const results = await Promise.allSettled(
      Array(attempts).fill(null).map(() => 
        searchWeb({ query: 'test', maxResults: 5 })
      )
    )
    
    const successful = results.filter(r => r.status === 'fulfilled')
    expect(successful.length).toBeGreaterThan(attempts * 0.5)
  })
  
  it('handles slow networks', async () => {
    setResponseDelay(2000) // 2 second delay
    
    const start = Date.now()
    await searchWeb({ query: 'test' })
    const duration = Date.now() - start
    
    expect(duration).toBeGreaterThanOrEqual(2000)
  })
})
```

### Testing Cache Behavior

```typescript
describe('Search Caching', () => {
  it('caches identical queries', async () => {
    const query = 'test caching'
    
    // First call - hits API
    const result1 = await searchWeb({ query, maxResults: 5 })
    const callCount1 = searchTestHelper.getCallCount()
    
    // Second call - should use cache
    const result2 = await searchWeb({ query, maxResults: 5 })
    const callCount2 = searchTestHelper.getCallCount()
    
    expect(result1).toEqual(result2)
    expect(callCount2).toBe(callCount1) // No new API calls
    expect(searchTestHelper.verifyCaching(query)).toBe(true)
  })
})
```

### E2E Search Testing with Playwright

```typescript
// tests/e2e/search-with-mocks.spec.ts
import { test, expect } from '@playwright/test'
import { setSearchTestScenario, SEARCH_TEST_SCENARIOS } from '../mocks/search-api-mocks'

test('handles search results in UI', async ({ page }) => {
  setSearchTestScenario(SEARCH_TEST_SCENARIOS.TECHNICAL_QUERY)
  
  await page.goto('/')
  const input = page.locator('[role="textbox"]').first()
  
  await input.type('How do React hooks work?')
  await page.keyboard.press('Enter')
  
  // Wait for response with search results
  await expect(input).toBeEnabled({ timeout: 30000 })
  
  // Verify search results are integrated
  const response = page.locator('[data-testid="message-assistant"]').last()
  await expect(response).toContainText(/React/)
})
```

### Debugging Search Tests

```typescript
// Enable detailed logging
import { searchTestHelper } from './mocks/search-api-mocks'

// After test execution
console.log('API Calls:', searchTestHelper.getCallCount())
console.log('Last Call:', searchTestHelper.getLastCall())
console.log('Fallback Chain Valid:', searchTestHelper.verifyFallbackChain())

// Check specific provider calls
console.log('SERP calls:', searchTestHelper.getCallCount('serp'))
console.log('OpenRouter calls:', searchTestHelper.getCallCount('openrouter'))
console.log('DuckDuckGo calls:', searchTestHelper.getCallCount('duckduckgo'))
```

## üìä Coverage Requirements

### Minimum Coverage Thresholds

```yaml
Global Coverage:
  branches: 80%
  functions: 80%
  lines: 80%
  statements: 80%

Critical Paths (90%+ required):
  - Authentication flows
  - Payment processing
  - Data validation
  - Error handling
  - Security features

UI Components (70%+ acceptable):
  - Visual components
  - Layout components
  - Static content

Excluded from Coverage:
  - Generated code (convex/_generated)
  - Type definitions (.d.ts)
  - Test files
  - Configuration files
  - Main entry point (main.tsx)
```

## üöÄ CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Test Suite
on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x, 22.x]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Type check
        run: npm run typecheck
      
      - name: Lint
        run: npm run lint
      
      - name: Unit tests with coverage
        run: npm run test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage/coverage-final.json
          flags: unittests
          
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run E2E tests
        run: npx playwright test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
```

## üéØ Testing Checklist

### Before Every PR

- [ ] All tests pass locally (`npm run test`)
- [ ] Coverage meets thresholds (`npm run test:coverage`)
- [ ] No skipped tests (`.skip()` or `.only()`)
- [ ] E2E tests pass (`npx playwright test`)
- [ ] No console.log statements in tests
- [ ] Mocks are properly cleaned up
- [ ] Test descriptions are clear and accurate

### Test Quality Indicators

‚úÖ **Good Test**
- Tests one specific behavior
- Has clear arrange/act/assert structure
- Uses semantic queries
- Handles async operations properly
- Cleans up after itself

‚ùå **Bad Test**
- Tests implementation details
- Uses arbitrary timeouts
- Has multiple assertions for different behaviors
- Depends on test execution order
- Uses hardcoded IDs or classes

## üîç Debugging Tests

### Vitest UI Mode

```bash
# Interactive test UI
npm run test:ui

# Debug specific test
npx vitest --reporter=verbose path/to/test.spec.ts
```

### Playwright Debugging

```bash
# Debug mode with inspector
npx playwright test --debug

# UI mode for interactive debugging
npx playwright test --ui

# Generate test code
npx playwright codegen localhost:5173

# View trace after failure
npx playwright show-trace trace.zip
```

### VS Code Integration

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Vitest Tests",
      "runtimeExecutable": "npx",
      "runtimeArgs": ["vitest", "--run", "${file}"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

## üìù Test Naming Conventions

### File Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.test.tsx    # Unit tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ChatInterface.styles.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useChat.ts
‚îÇ   ‚îî‚îÄ‚îÄ useChat.test.ts               # Hook tests
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ validation.ts
‚îÇ   ‚îî‚îÄ‚îÄ validation.test.ts            # Utility tests
tests/
‚îú‚îÄ‚îÄ e2e/                              # Playwright E2E tests
‚îÇ   ‚îú‚îÄ‚îÄ chat.spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ pages/
‚îÇ       ‚îî‚îÄ‚îÄ ChatPage.ts
‚îî‚îÄ‚îÄ integration/                      # Integration tests
    ‚îî‚îÄ‚îÄ api.test.ts
```

### Test Descriptions

```typescript
// ‚úÖ Good: Descriptive and behavior-focused
describe('ChatInterface', () => {
  it('should display user message after sending', async () => {})
  it('should show error when network fails', async () => {})
  it('should disable send button while processing', async () => {})
})

// ‚ùå Bad: Vague or implementation-focused
describe('ChatInterface', () => {
  it('works', async () => {})
  it('sets state correctly', async () => {})
  it('calls API', async () => {})
})
```

## üö® Common Pitfalls to Avoid

### React 19 Specific Pitfalls

#### 1. Trying to Redefine React.act
```typescript
// ‚ùå BAD: Will throw "Cannot redefine property: act"
if (!React.act) {
  (React as any).act = customAct
}

// ‚úÖ GOOD: Use React.act directly
const act = React.act // React 19 exports it
```

#### 2. Using Outdated Testing Library Versions
```json
// ‚ùå BAD: Old versions don't support React 19
"@testing-library/react": "^14.0.0"

// ‚úÖ GOOD: Use v16+ for React 19
"@testing-library/react": "^16.0.0"
```

### 1. Testing Implementation Details

```typescript
// ‚ùå BAD: Testing internal state
expect(component.state.isLoading).toBe(true)

// ‚úÖ GOOD: Testing user-visible behavior
expect(screen.getByRole('progressbar')).toBeInTheDocument()
```

### 2. Not Cleaning Up

```typescript
// ‚ùå BAD: No cleanup
test('test 1', () => {
  localStorage.setItem('key', 'value')
  // Test...
})

// ‚úÖ GOOD: Proper cleanup
afterEach(() => {
  localStorage.clear()
  vi.clearAllMocks()
})
```

### 3. Arbitrary Timeouts

```typescript
// ‚ùå BAD: Fixed timeout
await new Promise(resolve => setTimeout(resolve, 2000))

// ‚úÖ GOOD: Wait for specific condition
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument()
})
```

### 4. Testing Third-Party Libraries

```typescript
// ‚ùå BAD: Testing React Router
expect(mockNavigate).toHaveBeenCalledWith('/home')

// ‚úÖ GOOD: Testing the result
expect(window.location.pathname).toBe('/home')
```

## üéì Testing Philosophy

### The Testing Trophy (2025 Approach)

```
       /\        E2E Tests (10%)
      /  \       - Critical user journeys
     /    \      - Smoke tests
    /------\     Integration Tests (30%)
   /        \    - Component integration
  /          \   - API integration
 /            \  Unit Tests (60%)
/______________\ - Business logic
                 - Utilities
                 - Hooks
```

### Key Principles

1. **Write tests that give confidence**: Focus on critical paths
2. **Test behavior, not implementation**: What the user experiences
3. **Maintain test hygiene**: Keep tests simple, fast, and reliable
4. **Embrace the testing trophy**: More integration tests than the traditional pyramid
5. **Use the right tool**: Unit tests for logic, E2E for workflows
6. **Test accessibility**: Include a11y testing in your workflow
7. **Performance matters**: Monitor test execution time

## üóÑÔ∏è Convex Database Type Testing

### Testing Convex Functions with Type Safety

Convex functions with proper type validation provide excellent test reliability. Here's how to ensure type safety in tests:

#### 1. Mock Convex Functions with Correct Types

```typescript
// tests/mocks/convex-mocks.ts
import { vi } from 'vitest'
import type { Doc, Id } from '../../convex/_generated/dataModel'
import type { api } from '../../convex/_generated/api'

// Create type-safe mock responses
export const mockChat: Doc<"chats"> = {
  _id: 'test-chat-id' as Id<"chats">,
  _creationTime: Date.now(),
  title: 'Test Chat',
  userId: 'test-user-id' as Id<"users">,
  sessionId: undefined,
  shareId: 'test-share-id',
  publicId: 'test-public-id',
  privacy: 'private',
  createdAt: Date.now(),
  updatedAt: Date.now(),
  rollingSummary: undefined,
  rollingSummaryUpdatedAt: undefined,
}

// Mock Convex client with type preservation
export const mockConvexClient = {
  query: vi.fn((func: any, args?: any) => {
    // Return type-safe mocks based on function
    if (func === api.chats.getUserChats) {
      return Promise.resolve([mockChat])
    }
    return Promise.resolve(null)
  }),
  mutation: vi.fn(),
  action: vi.fn(),
}
```

#### 2. Type Validation in Unit Tests

```typescript
// convex/chats/core.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { convexTest } from 'convex-test'
import schema from '../schema'
import { api } from '../_generated/api'
import type { Doc, Id } from '../_generated/dataModel'

describe('Chat Functions Type Safety', () => {
  let t: ReturnType<typeof convexTest>
  
  beforeEach(() => {
    t = convexTest(schema)
  })
  
  it('should return properly typed chat document', async () => {
    // Create test data with correct types
    const chatId = await t.run(api.chats.createChat, {
      title: 'Test Chat',
      sessionId: 'test-session'
    })
    
    // TypeScript ensures chatId is Id<"chats">
    const chat = await t.run(api.chats.getChatById, { 
      chatId, // Type-safe!
      sessionId: 'test-session' 
    })
    
    // TypeScript knows chat is Doc<"chats"> | null
    expect(chat).toBeDefined()
    expect(chat?.title).toBe('Test Chat')
    
    // This would cause a TypeScript error:
    // expect(chat?.nonExistentField).toBe('something')
  })
  
  it('should validate ID types at compile time', async () => {
    // This would fail TypeScript compilation:
    // await t.run(api.chats.getChatById, { 
    //   chatId: 'invalid-string', // Error: Type 'string' is not assignable to type 'Id<"chats">'
    //   sessionId: 'test' 
    // })
    
    // Correct usage with proper ID type
    const validId = 'j97...abc' as Id<"chats">
    const result = await t.run(api.chats.getChatById, { 
      chatId: validId,
      sessionId: 'test' 
    })
    
    expect(result).toBeNull() // Chat doesn't exist
  })
})
```

#### 3. Testing Validator Constraints

```typescript
describe('Convex Validator Testing', () => {
  it('should validate function arguments', async () => {
    const t = convexTest(schema)
    
    // Test invalid arguments - should throw
    await expect(
      t.run(api.chats.createChat, {
        title: 123, // Wrong type - should be string
        sessionId: 'valid-session'
      } as any)
    ).rejects.toThrow('Validator error')
    
    // Test missing required arguments
    await expect(
      t.run(api.chats.createChat, {
        // Missing required 'title' field
        sessionId: 'valid-session'
      } as any)
    ).rejects.toThrow()
  })
  
  it('should validate return types', async () => {
    const t = convexTest(schema)
    
    // Function with returns validator
    const chats = await t.run(api.chats.getUserChats, {
      sessionId: 'test-session'
    })
    
    // TypeScript knows this is an array of chats
    expect(Array.isArray(chats)).toBe(true)
    chats.forEach(chat => {
      expect(chat).toHaveProperty('_id')
      expect(chat).toHaveProperty('title')
      expect(typeof chat.title).toBe('string')
    })
  })
})
```

#### 4. Integration Testing with Type Safety

```typescript
// tests/integration/chat-with-types.test.ts
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import { ConvexProvider } from 'convex/react'
import { ChatInterface } from '../../src/components/ChatInterface'
import { mockConvexClient } from '../mocks/convex-mocks'
import type { Doc, Id } from '../../convex/_generated/dataModel'

describe('Chat Interface with Convex Types', () => {
  it('should handle typed Convex responses', async () => {
    // Mock with proper types
    const mockChats: Doc<"chats">[] = [
      {
        _id: 'chat1' as Id<"chats">,
        _creationTime: Date.now(),
        title: 'Chat 1',
        userId: 'user1' as Id<"users">,
        sessionId: undefined,
        shareId: 'share1',
        publicId: 'public1',
        privacy: 'private',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        rollingSummary: undefined,
        rollingSummaryUpdatedAt: undefined,
      }
    ]
    
    mockConvexClient.query.mockResolvedValueOnce(mockChats)
    
    render(
      <ConvexProvider client={mockConvexClient as any}>
        <ChatInterface />
      </ConvexProvider>
    )
    
    await waitFor(() => {
      expect(screen.getByText('Chat 1')).toBeInTheDocument()
    })
    
    // Verify type-safe query was called
    expect(mockConvexClient.query).toHaveBeenCalledWith(
      expect.anything(), // api.chats.getUserChats
      expect.objectContaining({
        sessionId: expect.any(String)
      })
    )
  })
})
```

#### 5. Testing Type Errors with Snapshot Testing

```typescript
// tests/type-checking/convex-types.test.ts
import { describe, it, expect } from 'vitest'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

describe('Convex Type Checking', () => {
  it('should catch type errors in Convex functions', async () => {
    try {
      await execAsync('npx tsc -p convex --noEmit')
      // If no error, types are valid
      expect(true).toBe(true)
    } catch (error: any) {
      // Check for expected type errors
      const output = error.stdout + error.stderr
      
      // Should NOT have these errors
      expect(output).not.toContain('Cannot find module')
      expect(output).not.toContain('_generated')
      
      // Log unexpected errors for debugging
      if (output.includes('error TS')) {
        console.error('TypeScript errors found:', output)
        throw new Error('Unexpected TypeScript errors in Convex code')
      }
    }
  })
  
  it('should validate schema matches usage', async () => {
    // Run custom type checker
    const { stdout } = await execAsync('node scripts/check-convex-types.mjs')
    
    expect(stdout).toContain('All Convex type checks passed')
    expect(stdout).not.toContain('error:')
    expect(stdout).not.toContain('warning:')
  })
})
```

### Best Practices for Convex Type Testing

#### DO's ‚úÖ

1. **Use Generated Types Everywhere**
   ```typescript
   import type { Doc, Id } from '../convex/_generated/dataModel'
   // Never create manual type definitions
   ```

2. **Test Type Constraints**
   ```typescript
   // Verify validators reject invalid data
   await expect(invalidCall).rejects.toThrow()
   ```

3. **Mock with Correct Types**
   ```typescript
   const mockId: Id<"users"> = 'test-id' as Id<"users">
   // Don't use plain strings
   ```

4. **Use convex-test Package**
   ```typescript
   import { convexTest } from 'convex-test'
   const t = convexTest(schema)
   ```

5. **Test Both Success and Failure Cases**
   ```typescript
   // Test valid inputs
   expect(await validCall()).toBeDefined()
   // Test invalid inputs
   await expect(invalidCall()).rejects.toThrow()
   ```

#### DON'Ts ‚ùå

1. **Don't Skip Type Validation**
   ```typescript
   // ‚ùå BAD: Using 'as any' to bypass types
   await t.run(api.function, { invalid: 'data' } as any)
   
   // ‚úÖ GOOD: Fix the types or test the validation
   await expect(
     t.run(api.function, { invalid: 'data' })
   ).rejects.toThrow()
   ```

2. **Don't Mock _generated Files**
   ```typescript
   // ‚ùå BAD: Mocking generated types
   vi.mock('../convex/_generated/dataModel')
   
   // ‚úÖ GOOD: Use the real types
   import type { Doc } from '../convex/_generated/dataModel'
   ```

3. **Don't Test Convex Internals**
   ```typescript
   // ‚ùå BAD: Testing Convex's type generation
   expect(generatedTypes).toMatchSnapshot()
   
   // ‚úÖ GOOD: Test your function behavior
   expect(await myFunction()).toBe(expectedResult)
   ```

### Continuous Type Validation

#### Pre-commit Hook
```json
// package.json
"lint-staged": {
  "convex/**/*.ts": [
    "npm run check:convex-types",
    "npm run lint:convex-strict"
  ]
}
```

#### CI Pipeline
```yaml
# .github/workflows/ci.yml
- name: Convex Type Validation
  run: |
    npm run typecheck
    npm run check:convex-types
    npm run lint:convex-strict
```

#### Watch Mode for Development
```bash
# Run in separate terminal during development
npm run check:convex-watch
```

### Type Error Reference

| Error | Cause | Preferred Solution |
|-------|-------|----------|
| `Type 'string' is not assignable to type 'Id<"table">'` | Using plain string for ID | Create records to get real typed IDs (avoid casts where possible) |
| `Property does not exist on type 'Doc<"table">'` | Accessing non-existent field | Check schema definition |
| `Expected 2 arguments, but got 1` | Missing required args | Add all required arguments |
| `Type instantiation is excessively deep` | Complex nested types | Simplify or increase TypeScript depth limit |

## üåç Environment Detection in Tests

### Unified isDev Detection System

Our codebase uses a unified environment detection system that works across Vite, Convex, and Node.js environments without violating their constraints.

#### Architecture Overview

```typescript
// Frontend (src/lib/environment.ts)
import { isDev, environment } from '@/lib/environment';

// Convex Actions (can use process.env)
import { isDevAction } from '../lib/environment';

// Convex Queries/Mutations (no process.env access)
import { isDevFromContext } from '../lib/environment';
```

#### Testing Environment Detection

##### 1. Mock Environment in Unit Tests

```typescript
// tests/unit/environment.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { isDevelopment } from '@/lib/environment'

describe('Environment Detection', () => {
  beforeEach(() => {
    // Reset environment
    vi.unstubAllEnvs()
  })
  
  it('should detect development from Vite DEV flag', () => {
    vi.stubEnv('DEV', 'true')
    expect(isDevelopment()).toBe(true)
  })
  
  it('should detect production deployment', () => {
    vi.stubEnv('VITE_CONVEX_URL', 'https://vivid-boar-858.convex.cloud')
    vi.stubEnv('DEV', 'false')
    expect(isDevelopment()).toBe(false)
  })
  
  it('should detect localhost as development', () => {
    // Mock window.location
    Object.defineProperty(window, 'location', {
      value: { hostname: 'localhost' },
      writable: true
    })
    expect(isDevelopment()).toBe(true)
  })
})
```

##### 2. Test Convex Environment Detection

```typescript
// convex/lib/environment.test.ts
import { describe, it, expect, vi } from 'vitest'
import { isDevDeployment, isDevAction, isDevFromContext } from './environment'

describe('Convex Environment Detection', () => {
  it('should identify known dev deployments', () => {
    expect(isDevDeployment('diligent-greyhound-240')).toBe(true)
    expect(isDevDeployment('vivid-boar-858')).toBe(false)
  })
  
  it('should handle deployment prefixes', () => {
    expect(isDevDeployment('dev:some-deployment')).toBe(true)
    expect(isDevDeployment('prod:some-deployment')).toBe(false)
  })
  
  it('should detect action environment', () => {
    // Mock process.env for actions
    vi.stubEnv('NODE_ENV', 'development')
    expect(isDevAction()).toBe(true)
    
    vi.stubEnv('NODE_ENV', 'production')
    vi.stubEnv('CONVEX_DEPLOYMENT', 'prod:vivid-boar-858')
    expect(isDevAction()).toBe(false)
  })
  
  it('should use context hints in queries/mutations', () => {
    // Without hint, defaults to production (safe)
    expect(isDevFromContext()).toBe(false)
    
    // With hint
    expect(isDevFromContext('diligent-greyhound-240')).toBe(true)
    expect(isDevFromContext('vivid-boar-858')).toBe(false)
  })
})
```

##### 3. E2E Environment Testing

```typescript
// tests/e2e/environment.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Environment-specific behavior', () => {
  test('should show dev features in development', async ({ page }) => {
    // Set dev environment
    await page.addInitScript(() => {
      window.localStorage.setItem('DEBUG_MODE', 'true')
    })
    
    await page.goto('/')
    
    // Dev-only features should be visible
    const devTools = page.locator('[data-testid="dev-tools"]')
    await expect(devTools).toBeVisible()
  })
  
  test('should hide dev features in production', async ({ page }) => {
    // Mock production environment
    await page.route('**/convex/**', route => {
      route.fulfill({
        headers: {
          'X-Convex-Deployment': 'vivid-boar-858'
        }
      })
    })
    
    await page.goto('/')
    
    // Dev features should be hidden
    const devTools = page.locator('[data-testid="dev-tools"]')
    await expect(devTools).not.toBeVisible()
  })
})
```

#### Known Deployments

Update these when deployments change:

```typescript
// convex/lib/environment.ts
const DEV_DEPLOYMENTS = [
  'diligent-greyhound-240',  // Primary dev deployment
  'localhost',
  'local',
];

const PROD_DEPLOYMENTS = [
  'vivid-boar-858',  // Primary production deployment
];
```

#### Environment Detection Flow

```mermaid
graph TD
    A[Environment Check] --> B{Context Type?}
    B -->|Frontend| C[Check Vite DEV]
    B -->|Convex Action| D[Check process.env]
    B -->|Query/Mutation| E[Use Hardcoded Values]
    
    C --> F{Is DEV true?}
    F -->|Yes| G[Development]
    F -->|No| H[Check URL Pattern]
    H --> I{Localhost?}
    I -->|Yes| G
    I -->|No| J[Check Deployment Name]
    
    D --> K{NODE_ENV?}
    K -->|development| G
    K -->|production| L[Production]
    K -->|undefined| M[Check CONVEX_DEPLOYMENT]
    
    E --> N{Known Deployment?}
    N -->|greyhound| G
    N -->|boar| L
    N -->|Unknown| L
    
    J --> O{Match Pattern?}
    O -->|Dev Pattern| G
    O -->|Prod Pattern| L
    O -->|No Match| L
```

#### Common Patterns

##### Conditional Logging

```typescript
import { isDev } from '@/lib/environment';
import { getEnvLogger } from '@/lib/environment';

// Simple check
if (isDev()) {
  console.log('Debug information');
}

// Using logger utility
const logger = getEnvLogger();
logger.debug('Only logs in development');
logger.error('Always logs'); // Errors are always visible
```

##### Feature Flags

```typescript
import { environment } from '@/lib/environment';

export const features = {
  debugPanel: environment.isDev,
  verboseLogging: environment.isDev,
  mockData: environment.isDev && !window.location.search.includes('real-data'),
  analyticsTracking: environment.isProduction,
};
```

##### Convex Function Logging

```typescript
// In a Convex action
import { action } from './_generated/server';
import { isDevAction, getEnvLogger } from '../lib/environment';

export const myAction = action(async (ctx, args) => {
  const logger = getEnvLogger(isDevAction());
  
  logger.debug('Action started', args);
  // Debug logs only in development
  
  const result = await performWork();
  
  logger.debug('Action completed', result);
  return result;
});

// In a query/mutation (no process.env)
import { query } from './_generated/server';
import { isDevFromContext } from '../lib/environment';

export const myQuery = query(async (ctx, args) => {
  const isDev = isDevFromContext();
  
  // This will be true in greyhound deployment, false in boar
  if (isDev) {
    // Development-only behavior
  }
  
  return data;
});
```

#### Testing Guidelines

1. **Always mock environment in tests** - Don't rely on actual environment
2. **Test both dev and prod paths** - Ensure features work in both
3. **Use deployment hints sparingly** - Only when frontend needs to pass context
4. **Update hardcoded deployments** - When deployment names change
5. **Default to production** - Safer to hide dev features than expose them

#### Troubleshooting

| Issue | Cause | Solution |
|-------|-------|----------|
| `process.env undefined in query` | Queries can't access process.env | Use `isDevFromContext()` instead |
| `isDev always false` | Deployment not in DEV_DEPLOYMENTS | Add deployment to known list |
| `Different behavior local vs deployed` | Different detection methods | Test with actual deployment names |
| `import.meta.env undefined` | Not in Vite context | Use Node.js detection in scripts |

## üîó Resources & Documentation

### Official Documentation
- [Vitest Documentation](https://vitest.dev/)
- [Playwright Documentation](https://playwright.dev/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [MSW Documentation](https://mswjs.io/)
- [Convex Testing Guide](https://docs.convex.dev/test)
- [Convex TypeScript Guide](https://docs.convex.dev/using/typescript)

### Recommended Reading
- [Common Testing Mistakes](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)
- [Test Patterns](https://testingjavascript.com/)
- [Effective Snapshot Testing](https://kentcdodds.com/blog/effective-snapshot-testing)

### Tools & Extensions
- VS Code: Vitest Extension
- VS Code: Playwright Test for VS Code
- Chrome: React Developer Tools
- Chrome: Testing Playground

## üîß Troubleshooting Guide

### Vitest Issues

#### Worker Pool Errors
```bash
# Error: "Cannot find module" or worker termination
# Solution: Switch to forks pool
vitest run --pool=forks

# For CI environments
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

#### Memory Issues in CI
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    pool: 'forks',
    poolOptions: {
      forks: {
        singleFork: true, // Run tests sequentially in one process
      }
    },
    maxConcurrency: 1, // Limit concurrent tests
  }
})
```

### Playwright Issues

#### Tests Failing Only in CI
```typescript
// playwright.config.ts
export default defineConfig({
  // Increase timeouts for CI
  use: {
    actionTimeout: process.env.CI ? 30000 : 10000,
    navigationTimeout: process.env.CI ? 60000 : 30000,
  },
  
  // More retries in CI
  retries: process.env.CI ? 3 : 1,
  
  // Disable parallelism if flaky
  workers: process.env.CI ? 1 : undefined,
})
```

#### Network Errors (ERR_CONNECTION_REFUSED)
```typescript
// Ensure server is ready before tests
webServer: {
  command: 'npm run dev',
  url: 'http://localhost:5173',
  reuseExistingServer: !process.env.CI,
  // Add health check
  timeout: 120 * 1000,
  stdout: 'pipe',
  stderr: 'pipe',
}

// Or use custom wait logic
test.beforeAll(async () => {
  // Wait for server to be ready
  await waitForServer('http://localhost:5173', { timeout: 30000 })
})
```

### React Testing Library Issues

#### Act Warnings
```typescript
// Warning: "An update was not wrapped in act(...)"
// Solution 1: Use async utilities
await waitFor(() => {
  expect(screen.getByText('Done')).toBeInTheDocument()
})

// Solution 2: Ensure all updates complete
await act(async () => {
  await userEvent.click(button)
})

// Solution 3: For React 19, act is automatic with RTL v16+
// Just ensure you're using the latest version
```

#### Timeout Issues
```typescript
// Increase timeout for slow operations
await waitFor(
  () => expect(screen.getByText('Loaded')).toBeInTheDocument(),
  { timeout: 5000 } // Default is 1000ms
)

// For findBy queries
const element = await screen.findByText('Loaded', {}, { timeout: 5000 })
```

---

**Remember**: Good tests are an investment in code quality and team velocity. They should make refactoring safe and development faster, not slower. When in doubt, test what the user would experience.
