---
description: "Unit and Component testing guidelines with Vitest and React Testing Library"
globs: "**/*.{test,spec}.{ts,tsx}"
alwaysApply: true
---

# Unit & Component Testing

## ğŸ¯ Vitest Configuration & Best Practices

### Worker Pool Selection (Vitest)
Use cases and commands:
```bash
# Force forks (child_process-based)
vitest run --pool=forks
# CI standard
vitest run --pool=vmForks --poolOptions.vmForks.singleFork
```

### Optimal Configuration
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { '@': path.resolve(__dirname, './src') } },
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
    pool: 'forks', // Avoids tinypool issues
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      thresholds: { global: { branches: 80, functions: 80, lines: 80, statements: 80 } }
    },
  },
})
```

## ğŸ§ª React Testing Patterns

### Component Testing
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ChatInterface', () => {
  let user: ReturnType<typeof userEvent.setup>
  beforeEach(() => { user = userEvent.setup() })

  it('should handle user input', async () => {
    render(<ChatInterface />)
    const input = screen.getByRole('textbox', { name: /message/i })
    const send = screen.getByRole('button', { name: /send/i })
    
    await user.type(input, 'Hello')
    await user.click(send)
    
    await waitFor(() => {
      expect(screen.getByText('Hello')).toBeInTheDocument()
    })
  })
})
```

### Testing Custom Hooks
```typescript
import { renderHook, act } from '@testing-library/react'
import { useChat } from '../hooks/useChat'

describe('useChat', () => {
  it('should manage state', async () => {
    const { result } = renderHook(() => useChat())
    expect(result.current.messages).toEqual([])
    
    await act(async () => {
      await result.current.sendMessage('Hello')
    })
    expect(result.current.messages).toHaveLength(1)
  })
})
```

## ğŸš¨ Common Pitfalls

1. **Testing Implementation Details**: Avoid testing internal state (`component.state`). Test user-visible behavior (`screen.getByRole`).
2. **Not Cleaning Up**: Use `afterEach(() => { cleanup(); vi.clearAllMocks() })`.
3. **Arbitrary Timeouts**: Use `waitFor` or `findBy`, never `setTimeout`.
4. **Third-Party Libraries**: Test the result/effect, not the library internals.

## ğŸ” Debugging Vitest
```bash
npm run test:ui
npx vitest --reporter=verbose path/to/test.spec.ts
```
