---
description: Pagination architecture and usage for chat messages; single source of truth for design, usage, and migration
alwaysApply: true
---

# Pagination Architecture & Guide

This rule consolidates the pagination architecture and usage guidance for loading chat messages.

## Architecture (Goals & Design)

- Reduce initial load and bound DOM nodes.
- Initial load fetches the most recent N (default 50) messages; subsequent loads fetch older pages using a server-provided cursor.
- Server:
  - `getRecentChatMessages(chatId, limit)` returns latest messages and a cursor.
  - `loadMoreMessages(chatId, cursor, limit)` returns the next page and next cursor.
  - Validate with `v` validators in Convex.
- Client data layer:
  - Repository exposes `getMessagesPaginated(chatId, opts)` and returns `{ messages, cursor, hasMore }`.
  - Keep `getMessages(chatId)` for full-history export paths.
- UI:
  - `usePaginatedMessages(chatId)` manages state, cursor, `loadMore`, errors, retries.
  - `MessageList` shows 3–5 skeletons on initial load and a small skeleton while loading more.

Parameters: initial/subsequent page size 50; target ≤ 200 DOM nodes steady state (recent pages + buffer).

## Error Handling & Retries

- Exponential backoff (1s, 2s, 4s) up to 3 attempts.
- Detect offline; queue retry when back online.
- Fallback to non-paginated fetch after repeated failures to avoid hard blocks.

## Race Conditions & Guards

- Session guard discards obsolete results if chat changes mid-retry.
- Serialize concurrent `loadMore` calls.

## Edge Cases

- Deleted messages after cursor issuance — server returns valid next cursor or `hasMore=false`.
- Invalid/expired cursor — backend validates and returns fresh cursor or error.
- Unmount during retry — timers are cleared on unmount.

## Usage Example

```tsx
import { usePaginatedMessages } from "../../hooks/usePaginatedMessages";

const {
  messages,
  isLoading,
  isLoadingMore,
  hasMore,
  error,
  retryCount,
  loadMore,
  refresh,
  clearError,
} = usePaginatedMessages({ chatId, initialLimit: 50, enabled: Boolean(chatId) });
```

UI patterns: show skeletons on initial load; disable load-more while `isLoadingMore`; display retry UI via `clearError` + `loadMore`.

## Performance Tips

- Keep `initialLimit` moderate (50–100) for fast first paint.
- Consider virtualization for extremely large threads.
- Memoize message item components to avoid unnecessary re-renders.

## Migration

- Prefer `getMessagesPaginated` over `getMessages` in UI/services.
- For summarization, fetch recent messages only (e.g., last 50–100).
- Only fetch full history for explicit export flows.

